

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; knockpy 1.0.3 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Tutorials" href="usage.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> knockpy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-knockpy.knockoff_filter">The KnockoffFilter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-knockpy.knockoff_stats">Feature Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-knockpy.knockoffs">Gaussian and Fixed-X Knockoff Samplers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-knockpy.metro">Metropolized Samplers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-knockpy.smatrix">S-matrix computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kpytorch">Kpytorch</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-knockpy.dgp">Quickly creating data-generating processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-knockpy.utilities">Utility functions</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">knockpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/apiref.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-knockpy.knockoff_filter">
<span id="the-knockofffilter"></span><h2>The KnockoffFilter<a class="headerlink" href="#module-knockpy.knockoff_filter" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="knockpy.knockoff_filter.KnockoffFilter">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_filter.</code><code class="sig-name descname">KnockoffFilter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fstat</span><span class="o">=</span><span class="default_value">'lasso'</span></em>, <em class="sig-param"><span class="n">ksampler</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">fstat_kwargs</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">knockoff_kwargs</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_filter.html#KnockoffFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_filter.KnockoffFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs knockoff-based inference, from start to finish.</p>
<p>This wraps both the <code class="docutils literal notranslate"><span class="pre">knockoffs.KnockoffSampler</span></code> and 
<code class="docutils literal notranslate"><span class="pre">knockoff_stats.FeatureStatistic</span></code> classes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fstat</strong><span class="classifier">str or knockpy.knockoff_stats.FeatureStatistic</span></dt><dd><p>The feature statistic to use in the knockoff filter.
This may also be a string identifier, including:
- ‘lasso’ or ‘lcd’: cross-validated lasso coefficients differences 
- ‘lsm’: signed maximum of the lasso path statistic as</p>
<blockquote>
<div><p>in Barber and Candes 2015</p>
</div></blockquote>
<ul class="simple">
<li><p>‘dlasso’: Cross-validated debiased lasso coefficients</p></li>
<li><p>‘ridge’: Cross validated ridge coefficients</p></li>
<li><p>‘ols’: Ordinary least squares coefficients</p></li>
<li><p>‘margcorr’: marginal correlations between features and response</p></li>
<li><p>‘deeppink’: The deepPINK statistic as in Lu et al. 2018</p></li>
<li><p>‘randomforest’: A random forest with swap importances</p></li>
</ul>
</dd>
<dt><strong>ksampler</strong><span class="classifier">str or knockpy.knockoffs.KnockoffSampler</span></dt><dd><p>The knockoff sampler to use in the knockoff filter.
This may also be a string identifier, including:
- ‘gaussian’: Gaussian Model-X knockoffs
- ‘fx’: Fixed-X knockoffs
- ‘metro’: Generic metropolized knockoff sampler.
- ‘artk’: t-tailed Markov chain
- ‘blockt’: Blocks of t-distributed 
- ‘gibbs_grid’: Discrete gibbs grid
An alternative to specifying the ksampler is to simply pass
in a knockoff matrix during the <code class="docutils literal notranslate"><span class="pre">forward</span></code> call.</p>
</dd>
<dt><strong>fstat_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Kwargs to pass to the feature statistic <code class="docutils literal notranslate"><span class="pre">fit</span></code> function,
excluding the required arguments, defaults to {}</p>
</dd>
<dt><strong>knockoff_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Kwargs for instantiating the knockoff sampler argument if
the ksampler argument is a string identifier. This can be
the empt dict for some identifiers such as “gaussian” or “fx”,
but additional keyword arguments are required for complex samplers
such as the “metro” identifier. Defaults to {}</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here we fit the KnockoffFilter on fake data from a Gaussian
linear model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Fake data-generating process for Gaussian linear model</span>
<span class="kn">import</span> <span class="nn">knockpy</span> <span class="k">as</span> <span class="nn">kpy</span>
<span class="n">dgprocess</span> <span class="o">=</span> <span class="n">kpy</span><span class="o">.</span><span class="n">dgp</span><span class="o">.</span><span class="n">DGP</span><span class="p">()</span>
<span class="n">dgprocess</span><span class="o">.</span><span class="n">sample_data</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">sparsity</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># LCD statistic with Gaussian MX knockoffs</span>
<span class="c1"># This uses LedoitWolf covariance estimation by default.</span>
<span class="kn">from</span> <span class="nn">knockpy.knockoff_filter</span> <span class="kn">import</span> <span class="n">KnockoffFilter</span> 
<span class="n">kfilter</span> <span class="o">=</span> <span class="n">KnockoffFilter</span><span class="p">(</span> 
    <span class="n">fstat</span><span class="o">=</span><span class="s1">&#39;lcd&#39;</span><span class="p">,</span> 
    <span class="n">ksampler</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> 
    <span class="n">knockoff_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span><span class="s2">&quot;mvr&quot;</span><span class="p">},</span> 
<span class="p">)</span>
<span class="n">rejections</span> <span class="o">=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">dgprocess</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">dgprocess</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fstat</strong><span class="classifier">knockpy.knockoff_stats.FeatureStatistic</span></dt><dd><p>The feature statistics to use for inference. This inherits
from <code class="docutils literal notranslate"><span class="pre">knockoff_stats.FeatureStatistic</span></code>.</p>
</dd>
<dt><strong>ksampler</strong><span class="classifier">knockpy.knockoffs.KnockoffSampler</span></dt><dd><p>The knockoff sampler to use during inference. This eventually
inherits from <code class="docutils literal notranslate"><span class="pre">knockoffs.KnockoffSampler</span></code>.</p>
</dd>
<dt><strong>fstat_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of kwargs to pass to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> call of <code class="docutils literal notranslate"><span class="pre">self.fstat</span></code>.</p>
</dd>
<dt><strong>knockoff_kwargs</strong><span class="classifier">dict</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">ksampler</span></code> is not yet initialized, kwargs to pass to <code class="docutils literal notranslate"><span class="pre">ksampler</span></code>.</p>
</dd>
<dt><strong>Z</strong><span class="classifier">np.ndarray</span></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">2p</span></code>-dimsional array of feature and knockoff importances. The
first p coordinates correspond to features, the last p correspond
to knockoffs.</p>
</dd>
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped knockoff S-matrix used to generate knockoffs.</p>
</dd>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>rejections</strong><span class="classifier">np.ndarray</span></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped boolean array where rejections[j] == 1 iff the
the knockoff filter rejects the jth feature.</p>
</dd>
<dt><strong>G</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(2p,</span> <span class="pre">2p)</span></code>-shaped feature-knockoff covariance matrix</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>the knockoff data-dependent threshold used to select variables</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoff_filter.KnockoffFilter.forward" title="knockpy.knockoff_filter.KnockoffFilter.forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward</span></code></a>(X, y[, Xk, mu, Sigma, groups, fdr, …])</p></td>
<td><p>Runs the knockoff filter; returns whether each feature was rejected.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_filter.KnockoffFilter.make_selections" title="knockpy.knockoff_filter.KnockoffFilter.make_selections"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_selections</span></code></a>(W, fdr)</p></td>
<td><p>” Calculate data dependent threshhold and selections</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoff_filter.KnockoffFilter.sample_knockoffs" title="knockpy.knockoff_filter.KnockoffFilter.sample_knockoffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_knockoffs</span></code></a>()</p></td>
<td><p>Samples knockoffs during <code class="docutils literal notranslate"><span class="pre">forward</span></code>.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_filter.KnockoffFilter.forward">
<code class="sig-name descname">forward</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">Xk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Sigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fdr</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">fstat_kwargs</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">knockoff_kwargs</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">shrinkage</span><span class="o">=</span><span class="default_value">'ledoitwolf'</span></em>, <em class="sig-param"><span class="n">num_factors</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">recycle_up_to</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_filter.html#KnockoffFilter.forward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_filter.KnockoffFilter.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the knockoff filter; returns whether each feature was rejected.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped knockoff matrix. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, this will construct
knockoffs using <code class="docutils literal notranslate"><span class="pre">self.ksampler</span></code>.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">)</span></code>-shaped mean of the features. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, this defaults to
the empirical mean of the features.</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of the features. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, this
is estimated using the <code class="docutils literal notranslate"><span class="pre">shrinkage</span></code> option. This is ignored for
fixed-X knockoffs.</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> (regular knockoffs).</p>
</dd>
<dt><strong>fdr</strong><span class="classifier">float</span></dt><dd><p>The desired level of false discovery rate control.</p>
</dd>
<dt><strong>fstat_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs to pass to the feature statistic <code class="docutils literal notranslate"><span class="pre">fit</span></code> function,
excluding the required arguments.</p>
</dd>
<dt><strong>knockoff_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs for instantiating the knockoff sampler argument if
the ksampler argument is a string identifier. This can be
the empty dict for some identifiers such as “gaussian” or “fx”,
but additional keyword arguments are required for complex samplers
such as the “metro” identifier. Defaults to {}</p>
</dd>
<dt><strong>shrinkage</strong><span class="classifier">str</span></dt><dd><p>Shrinkage method if estimating the covariance matrix. Defaults to 
“LedoitWolf.” Other options are “MLE” and “glasso” (graphical lasso).</p>
</dd>
<dt><strong>num_factors</strong><span class="classifier">int</span></dt><dd><p>If num_factors is not <code class="docutils literal notranslate"><span class="pre">None</span></code> and Sigma is estimated,
assumes that the ground-truth Sigma is a factor model 
with rank <code class="docutils literal notranslate"><span class="pre">num_factors</span></code> to speed up computation.</p>
</dd>
<dt><strong>recycle_up_to</strong><span class="classifier">int or float</span></dt><dd><dl>
<dt>Three options:</dt><dd><ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">None</span></code>, does nothing.</p></li>
<li><p>if an integer &gt; 1, uses the first “recycle_up_to”</p></li>
</ul>
<p>rows of X as the the first “recycle_up_to” rows of knockoffs
- if a float between 0 and 1 (inclusive), interpreted
as the proportion of rows to recycle.</p>
</dd>
</dl>
<p>For more on recycling, see <a class="reference external" href="https://arxiv.org/abs/1602.03574">https://arxiv.org/abs/1602.03574</a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoff_filter.KnockoffFilter.make_selections">
<code class="sig-name descname">make_selections</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">W</span></em>, <em class="sig-param"><span class="n">fdr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_filter.html#KnockoffFilter.make_selections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_filter.KnockoffFilter.make_selections" title="Permalink to this definition">¶</a></dt>
<dd><p>” Calculate data dependent threshhold and selections</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoff_filter.KnockoffFilter.sample_knockoffs">
<code class="sig-name descname">sample_knockoffs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_filter.html#KnockoffFilter.sample_knockoffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_filter.KnockoffFilter.sample_knockoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples knockoffs during <code class="docutils literal notranslate"><span class="pre">forward</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-knockpy.knockoff_stats">
<span id="feature-statistics"></span><h2>Feature Statistics<a class="headerlink" href="#module-knockpy.knockoff_stats" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="knockpy.knockoff_stats.DeepPinkStatistic">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">DeepPinkStatistic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#DeepPinkStatistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.DeepPinkStatistic" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cv_score_model</span></code>(features, y, cv_score[, …])</p></td>
<td><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.DeepPinkStatistic.fit" title="knockpy.knockoff_stats.DeepPinkStatistic.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, Xk, y[, groups, feature_importance, …])</p></td>
<td><p>Wraps the FeatureStatistic class using DeepPINK to generate variable importances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">score_model</span></code>(features, y[, y_dist])</p></td>
<td><p>Computes mean-squared error of self.model on (features, y) when y is nonbinary, and computes 1 - accuracy otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>(features, y)</p></td>
<td><p>Given a model of the features and y, calculates feature importances as follows.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_path_feature_importances</span></code>(features, y[, …])</p></td>
<td><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see <a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_stats.DeepPinkStatistic.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">feature_importance</span><span class="o">=</span><span class="default_value">'deeppink'</span></em>, <em class="sig-param"><span class="n">antisym</span><span class="o">=</span><span class="default_value">'cd'</span></em>, <em class="sig-param"><span class="n">group_agg</span><span class="o">=</span><span class="default_value">'sum'</span></em>, <em class="sig-param"><span class="n">cv_score</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">train_kwargs</span><span class="o">=</span><span class="default_value">{'verbose': False}</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#DeepPinkStatistic.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.DeepPinkStatistic.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the FeatureStatistic class using DeepPINK to generate
variable importances.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>feature_importance</strong><span class="classifier">str</span></dt><dd><p>Specifies how to create feature importances from <code class="docutils literal notranslate"><span class="pre">model</span></code>. 
Four options:</p>
<blockquote>
<div><ul class="simple">
<li><p>“deeppink”: Use the deeppink feature importance</p></li>
</ul>
<p>defined in <a class="reference external" href="https://arxiv.org/abs/1809.01185">https://arxiv.org/abs/1809.01185</a>
- “unweighted”: Use the Z weights from the deeppink
paper without weighting them using the layers from
the MLP. Deeppink usually outperforms this feature
importance (but not always).
- “swap”: The default swap-statistic from 
<a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a>
- “swapint”: The swap-integral defined from
<a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p>
</div></blockquote>
<p>Defaults to deeppink, which is often both the most powerful and 
the most computationally efficient.</p>
</dd>
<dt><strong>antisym</strong><span class="classifier">str</span></dt><dd><p>The antisymmetric function used to create (ungrouped) feature
statistics. Three options: 
- “CD” (Difference of absolute vals of coefficients),
- “SM” (signed maximum).
- “SCD” (Simple difference of coefficients - NOT recommended)</p>
</dd>
<dt><strong>group_agg</strong><span class="classifier">str</span></dt><dd><p>For group knockoffs, specifies how to turn individual feature
statistics into grouped feature statistics. Two options: 
“sum” and “avg”.</p>
</dd>
<dt><strong>cv_score</strong><span class="classifier">bool</span></dt><dd><p>If true, score the feature statistic’s predictive accuracy
using cross validation. This is extremely expensive for random
forests.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs to pass to underlying RandomForest class</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoff_stats.FeatureStatistic">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">FeatureStatistic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#FeatureStatistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.FeatureStatistic" title="Permalink to this definition">¶</a></dt>
<dd><p>The base knockoff feature statistic class, which can wrap any
generic prediction algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>model :</strong></dt><dd><p>An instance of a class with a “train” or “fit” method
and a “predict” method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>model :</strong></dt><dd><p>A (predictive) model class underlying the variable importance
measures.</p>
</dd>
<dt><strong>inds</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,)</span></code>-dimensional array of indices representing the random
permutation applied to the concatenation of [X, Xk] before fitting
<code class="docutils literal notranslate"><span class="pre">gl.</span></code></p>
</dd>
<dt><strong>rev_inds</strong><span class="classifier">np.ndarray:</span></dt><dd><p>Indices which reverse the effect of <code class="docutils literal notranslate"><span class="pre">inds.</span></code> In particular, if
M is any <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2p)</span></code>-dimensional array, then <code class="docutils literal notranslate"><span class="pre">`M==M[:,</span> <span class="pre">inds][:,</span> <span class="pre">rev_inds]`</span></code></p>
</dd>
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>A metric of the model’s performance, as defined by <code class="docutils literal notranslate"><span class="pre">score_type</span></code>.</p>
</dd>
<dt><strong>score_type</strong><span class="classifier">str</span></dt><dd><p>One of MSE, CVMSE, accuracy, or cvaccuracy. (cv stands for
cross-validated)</p>
</dd>
<dt><strong>Z</strong><span class="classifier">np.ndarray</span></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">2p</span></code>-dimsional array of feature and knockoff importances. The
first p coordinates correspond to features, the last p correspond
to knockoffs.</p>
</dd>
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.FeatureStatistic.cv_score_model" title="knockpy.knockoff_stats.FeatureStatistic.cv_score_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cv_score_model</span></code></a>(features, y, cv_score[, …])</p></td>
<td><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.FeatureStatistic.fit" title="knockpy.knockoff_stats.FeatureStatistic.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, Xk, y[, groups, feature_importance, …])</p></td>
<td><p>Trains the model and creates feature importances.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.FeatureStatistic.score_model" title="knockpy.knockoff_stats.FeatureStatistic.score_model"><code class="xref py py-obj docutils literal notranslate"><span class="pre">score_model</span></code></a>(features, y[, y_dist])</p></td>
<td><p>Computes mean-squared error of self.model on (features, y) when y is nonbinary, and computes 1 - accuracy otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.FeatureStatistic.swap_feature_importances" title="knockpy.knockoff_stats.FeatureStatistic.swap_feature_importances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_feature_importances</span></code></a>(features, y)</p></td>
<td><p>Given a model of the features and y, calculates feature importances as follows.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.FeatureStatistic.swap_path_feature_importances" title="knockpy.knockoff_stats.FeatureStatistic.swap_path_feature_importances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_path_feature_importances</span></code></a>(features, y[, …])</p></td>
<td><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see <a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_stats.FeatureStatistic.cv_score_model">
<code class="sig-name descname">cv_score_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">features</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">cv_score</span></em>, <em class="sig-param"><span class="n">logistic_flag</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#FeatureStatistic.cv_score_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.FeatureStatistic.cv_score_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoff_stats.FeatureStatistic.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">feature_importance</span><span class="o">=</span><span class="default_value">'swap'</span></em>, <em class="sig-param"><span class="n">antisym</span><span class="o">=</span><span class="default_value">'cd'</span></em>, <em class="sig-param"><span class="n">group_agg</span><span class="o">=</span><span class="default_value">'avg'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#FeatureStatistic.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.FeatureStatistic.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the model and creates feature importances.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>feature_importance</strong><span class="classifier">str</span></dt><dd><p>Specifies how to create feature importances from <code class="docutils literal notranslate"><span class="pre">model</span></code>. 
Two options:</p>
<blockquote>
<div><ul class="simple">
<li><p>“swap”: The default swap-statistic from</p></li>
</ul>
<p><a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a>.
These are good measures of feature importance but
slightly slower.
- “swapint”: The swap-integral defined from
<a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p>
</div></blockquote>
<p>Defaults to ‘swap’</p>
</dd>
<dt><strong>antisym</strong><span class="classifier">str</span></dt><dd><p>The antisymmetric function used to create (ungrouped) feature
statistics. Three options: 
- “CD” (Difference of absolute vals of coefficients),
- “SM” (signed maximum).
- “SCD” (Simple difference of coefficients - NOT recommended)</p>
</dd>
<dt><strong>group_agg</strong><span class="classifier">str</span></dt><dd><p>For group knockoffs, specifies how to turn individual feature
statistics into grouped feature statistics. Two options: 
“sum” and “avg”.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier"><a href="#id1"><span class="problematic" id="id2">**</span></a>dict</span></dt><dd><p>kwargs to pass to the ‘train’ or ‘fit’ method of the model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoff_stats.FeatureStatistic.score_model">
<code class="sig-name descname">score_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">features</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">y_dist</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#FeatureStatistic.score_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.FeatureStatistic.score_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes mean-squared error of self.model on
(features, y) when y is nonbinary, and computes
1 - accuracy otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>loss</strong><span class="classifier">float</span></dt><dd><p>Either the MSE or one minus the accuracy of the model,
depending on whether y is continuous or binary.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoff_stats.FeatureStatistic.swap_feature_importances">
<code class="sig-name descname">swap_feature_importances</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">features</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#FeatureStatistic.swap_feature_importances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.FeatureStatistic.swap_feature_importances" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a model of the features and y, calculates feature importances
as follows.</p>
<p>For feature i, replace the feature with its knockoff and calculate
the relative increase in the loss. Similarly, for knockoff i, 
replace the knockoffs with its feature and calculate the relative
increase in the loss.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>features</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2p)</span></code>-shaped array of concatenated features and knockoffs,
which must be permuted by <code class="docutils literal notranslate"><span class="pre">self.inds</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Z_swap</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,)</span></code>-shaped array of variable importances such that
Z_swap is in the same permuted as <code class="docutils literal notranslate"><span class="pre">features</span></code> initially were.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoff_stats.FeatureStatistic.swap_path_feature_importances">
<code class="sig-name descname">swap_path_feature_importances</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">features</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">step_size</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">max_lambda</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#FeatureStatistic.swap_path_feature_importances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.FeatureStatistic.swap_path_feature_importances" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see
<a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoff_stats.LassoStatistic">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">LassoStatistic</code><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#LassoStatistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.LassoStatistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Lasso Statistic wrapper class</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cv_score_model</span></code>(features, y, cv_score[, …])</p></td>
<td><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.LassoStatistic.fit" title="knockpy.knockoff_stats.LassoStatistic.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, Xk, y[, groups, zstat, use_pyglm, …])</p></td>
<td><p>Wraps the FeatureStatistic class but uses cross-validated Lasso coefficients or Lasso path statistics as variable importances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">score_model</span></code>(features, y[, y_dist])</p></td>
<td><p>Computes mean-squared error of self.model on (features, y) when y is nonbinary, and computes 1 - accuracy otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>(features, y)</p></td>
<td><p>Given a model of the features and y, calculates feature importances as follows.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_path_feature_importances</span></code>(features, y[, …])</p></td>
<td><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see <a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_stats.LassoStatistic.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">zstat</span><span class="o">=</span><span class="default_value">'coef'</span></em>, <em class="sig-param"><span class="n">use_pyglm</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">group_lasso</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">antisym</span><span class="o">=</span><span class="default_value">'cd'</span></em>, <em class="sig-param"><span class="n">group_agg</span><span class="o">=</span><span class="default_value">'avg'</span></em>, <em class="sig-param"><span class="n">cv_score</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">debias</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">Ginv</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#LassoStatistic.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.LassoStatistic.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the FeatureStatistic class but uses cross-validated Lasso
coefficients or Lasso path statistics as variable importances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>zstat</strong><span class="classifier">str:</span></dt><dd><p>Two options for the variable importance measure:
- If ‘coef’, uses to cross-validated (group) lasso coefficients.
- If ‘lars_path’, uses the lambda value where each feature/knockoff
enters the lasso path (meaning becomes nonzero).
This defaults to coef.</p>
</dd>
<dt><strong>use_pyglm</strong><span class="classifier">bool</span></dt><dd><p>When fitting the group lasso, use the pyglm package if True (default).
Else, use the group_lasso package.</p>
</dd>
<dt><strong>y_dist</strong><span class="classifier">str</span></dt><dd><p>One of “binomial” or “gaussian”</p>
</dd>
<dt><strong>group_lasso</strong><span class="classifier">bool</span></dt><dd><p>If True, use a true group lasso. Else just use the sklearn ungrouped
lasso.</p>
</dd>
<dt><strong>antisym</strong><span class="classifier">str</span></dt><dd><p>The antisymmetric function used to create (ungrouped) feature
statistics. Three options: 
- “CD” (Difference of absolute vals of coefficients),
- “SM” (signed maximum).
- “SCD” (Simple difference of coefficients - NOT recommended)</p>
</dd>
<dt><strong>group_agg</strong><span class="classifier">str</span></dt><dd><p>For group knockoffs, specifies how to turn individual feature
statistics into grouped feature statistics. Two options: 
“sum” and “avg”.</p>
</dd>
<dt><strong>cv_score</strong><span class="classifier">bool</span></dt><dd><p>If true, score the feature statistic’s predictive accuracy
using cross validation.</p>
</dd>
<dt><strong>debias</strong><span class="classifier">bool:</span></dt><dd><p>If true, debias the lasso. See <a class="reference external" href="https://arxiv.org/abs/1508.02757">https://arxiv.org/abs/1508.02757</a></p>
</dd>
<dt><strong>Ginv</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,</span> <span class="pre">2p)</span></code>-shaped precision matrix for the feature-knockoff 
covariate distribution. This must be specified if <code class="docutils literal notranslate"><span class="pre">debias=True</span></code>.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs to pass to underlying Lasso classes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoff_stats.MargCorrStatistic">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">MargCorrStatistic</code><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#MargCorrStatistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.MargCorrStatistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Lasso Statistic wrapper class</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cv_score_model</span></code>(features, y, cv_score[, …])</p></td>
<td><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.MargCorrStatistic.fit" title="knockpy.knockoff_stats.MargCorrStatistic.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, Xk, y[, groups])</p></td>
<td><p>Wraps the FeatureStatistic class using marginal correlations  between X, Xk and y as variable importances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">score_model</span></code>(features, y[, y_dist])</p></td>
<td><p>Computes mean-squared error of self.model on (features, y) when y is nonbinary, and computes 1 - accuracy otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>(features, y)</p></td>
<td><p>Given a model of the features and y, calculates feature importances as follows.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_path_feature_importances</span></code>(features, y[, …])</p></td>
<td><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see <a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_stats.MargCorrStatistic.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#MargCorrStatistic.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.MargCorrStatistic.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the FeatureStatistic class using marginal correlations 
between X, Xk and y as variable importances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs to pass to underlying <code class="docutils literal notranslate"><span class="pre">combine_Z_stats</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoff_stats.OLSStatistic">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">OLSStatistic</code><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#OLSStatistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.OLSStatistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Lasso Statistic wrapper class</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cv_score_model</span></code>(features, y, cv_score[, …])</p></td>
<td><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.OLSStatistic.fit" title="knockpy.knockoff_stats.OLSStatistic.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, Xk, y[, groups, cv_score])</p></td>
<td><p>Wraps the FeatureStatistic class with OLS coefs as variable importances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">score_model</span></code>(features, y[, y_dist])</p></td>
<td><p>Computes mean-squared error of self.model on (features, y) when y is nonbinary, and computes 1 - accuracy otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>(features, y)</p></td>
<td><p>Given a model of the features and y, calculates feature importances as follows.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_path_feature_importances</span></code>(features, y[, …])</p></td>
<td><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see <a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_stats.OLSStatistic.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cv_score</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#OLSStatistic.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.OLSStatistic.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the FeatureStatistic class with OLS coefs as variable importances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>cv_score</strong><span class="classifier">bool</span></dt><dd><p>If true, score the feature statistic’s predictive accuracy
using cross validation.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs to pass to <code class="docutils literal notranslate"><span class="pre">combine_Z_stats</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoff_stats.RandomForestStatistic">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">RandomForestStatistic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#RandomForestStatistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.RandomForestStatistic" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cv_score_model</span></code>(features, y, cv_score[, …])</p></td>
<td><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.RandomForestStatistic.fit" title="knockpy.knockoff_stats.RandomForestStatistic.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, Xk, y[, groups, feature_importance, …])</p></td>
<td><p>Wraps the FeatureStatistic class using a Random Forest to  generate variable importances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">score_model</span></code>(features, y[, y_dist])</p></td>
<td><p>Computes mean-squared error of self.model on (features, y) when y is nonbinary, and computes 1 - accuracy otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>(features, y)</p></td>
<td><p>Given a model of the features and y, calculates feature importances as follows.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_path_feature_importances</span></code>(features, y[, …])</p></td>
<td><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see <a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_stats.RandomForestStatistic.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">feature_importance</span><span class="o">=</span><span class="default_value">'swap'</span></em>, <em class="sig-param"><span class="n">antisym</span><span class="o">=</span><span class="default_value">'cd'</span></em>, <em class="sig-param"><span class="n">group_agg</span><span class="o">=</span><span class="default_value">'sum'</span></em>, <em class="sig-param"><span class="n">cv_score</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#RandomForestStatistic.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.RandomForestStatistic.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the FeatureStatistic class using a Random Forest to 
generate variable importances.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>feature_importance</strong><span class="classifier">str</span></dt><dd><p>Specifies how to create feature importances from <code class="docutils literal notranslate"><span class="pre">model</span></code>. 
Three options:</p>
<blockquote>
<div><ul class="simple">
<li><p>“sklearn”: Use sklearn feature importances. These</p></li>
</ul>
<p>are very poor measures of feature importance, but
very fast.
- “swap”: The default swap-statistic from 
<a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a>.
These are good measures of feature importance but
slightly slower.
- “swapint”: The swap-integral defined from
<a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p>
</div></blockquote>
<p>Defaults to ‘swap’</p>
</dd>
<dt><strong>antisym</strong><span class="classifier">str</span></dt><dd><p>The antisymmetric function used to create (ungrouped) feature
statistics. Three options: 
- “CD” (Difference of absolute vals of coefficients),
- “SM” (signed maximum).
- “SCD” (Simple difference of coefficients - NOT recommended)</p>
</dd>
<dt><strong>group_agg</strong><span class="classifier">str</span></dt><dd><p>For group knockoffs, specifies how to turn individual feature
statistics into grouped feature statistics. Two options: 
“sum” and “avg”.</p>
</dd>
<dt><strong>cv_score</strong><span class="classifier">bool</span></dt><dd><p>If true, score the feature statistic’s predictive accuracy
using cross validation. This is extremely expensive for random
forests.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs to pass to underlying RandomForest class</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoff_stats.RidgeStatistic">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">RidgeStatistic</code><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#RidgeStatistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.RidgeStatistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Ridge statistic wrapper class</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cv_score_model</span></code>(features, y, cv_score[, …])</p></td>
<td><p>Similar to score_model, but uses cross-validated scoring if cv_score=True.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoff_stats.RidgeStatistic.fit" title="knockpy.knockoff_stats.RidgeStatistic.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X, Xk, y[, groups, antisym, group_agg, …])</p></td>
<td><p>Wraps the FeatureStatistic class but uses cross-validated Ridge coefficients as variable importances.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">score_model</span></code>(features, y[, y_dist])</p></td>
<td><p>Computes mean-squared error of self.model on (features, y) when y is nonbinary, and computes 1 - accuracy otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>(features, y)</p></td>
<td><p>Given a model of the features and y, calculates feature importances as follows.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_path_feature_importances</span></code>(features, y[, …])</p></td>
<td><p>Similar to <code class="docutils literal notranslate"><span class="pre">swap_feature_importances</span></code>; see <a class="reference external" href="http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf">http://proceedings.mlr.press/v89/gimenez19a/gimenez19a.pdf</a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoff_stats.RidgeStatistic.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">antisym</span><span class="o">=</span><span class="default_value">'cd'</span></em>, <em class="sig-param"><span class="n">group_agg</span><span class="o">=</span><span class="default_value">'avg'</span></em>, <em class="sig-param"><span class="n">cv_score</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#RidgeStatistic.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.RidgeStatistic.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the FeatureStatistic class but uses cross-validated Ridge
coefficients as variable importances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>antisym</strong><span class="classifier">str</span></dt><dd><p>The antisymmetric function used to create (ungrouped) feature
statistics. Three options: 
- “CD” (Difference of absolute vals of coefficients),
- “SM” (signed maximum).
- “SCD” (Simple difference of coefficients - NOT recommended)</p>
</dd>
<dt><strong>group_agg</strong><span class="classifier">str</span></dt><dd><p>For group knockoffs, specifies how to turn individual feature
statistics into grouped feature statistics. Two options: 
“sum” and “avg”.</p>
</dd>
<dt><strong>cv_score</strong><span class="classifier">bool</span></dt><dd><p>If true, score the feature statistic’s predictive accuracy
using cross validation.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Extra kwargs to pass to underlying Lasso classes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.calc_lars_path">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">calc_lars_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#calc_lars_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.calc_lars_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates locations at which X/knockoffs enter lasso 
model when regressed on y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>kwargs for <code class="docutils literal notranslate"><span class="pre">sklearn.linear_model.lars_path</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Z</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,)</span></code>-shaped array indicating the lasso path statistic
for each variable. (This means the maximum lambda such that
the lasso coefficient on variable j is nonzero.)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.calc_mse">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">calc_mse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#calc_mse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.calc_mse" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets MSE of a model</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.combine_Z_stats">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">combine_Z_stats</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Z</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">antisym</span><span class="o">=</span><span class="default_value">'cd'</span></em>, <em class="sig-param"><span class="n">group_agg</span><span class="o">=</span><span class="default_value">'sum'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#combine_Z_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.combine_Z_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Given Z scores (variable importances), returns (grouped) feature statistics</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Z</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,)</span></code>-shaped numpy array of Z-statistics. The first p values
correspond to true features, and the last p correspond to knockoffs
(in the same order as the true features).</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>antisym</strong><span class="classifier">str</span></dt><dd><p>The antisymmetric function used to create (ungrouped) feature
statistics. Three options: 
- “CD” (Difference of absolute vals of coefficients),
- “SM” (signed maximum).
- “SCD” (Simple difference of coefficients - NOT recommended)</p>
</dd>
<dt><strong>group_agg</strong><span class="classifier">str</span></dt><dd><p>For group knockoffs, specifies how to turn individual feature
statistics into grouped feature statistics. Two options: 
“sum” and “avg”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>an array of feature statistics. This is <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-dimensional
for regular knockoffs and <code class="docutils literal notranslate"><span class="pre">(num_groups,)</span></code>-dimensional for
group knockoffs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.data_dependent_threshhold">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">data_dependent_threshhold</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">W</span></em>, <em class="sig-param"><span class="n">fdr</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#data_dependent_threshhold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.data_dependent_threshhold" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate data-dependent threshhold given W statistics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray</span></dt><dd><p>p-length numpy array of feature statistics OR (p, batch_length) 
shaped array.</p>
</dd>
<dt><strong>fdr</strong><span class="classifier">float</span></dt><dd><p>desired level of false discovery rate control</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int</span></dt><dd><p>If offset = 0, control the modified FDR.
If offset = 1 (default), controls the FDR exactly.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">float or np.ndarray</span></dt><dd><p>The data-dependent threshhold. Either a float or a (batch_length,) 
dimensional array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.fit_group_lasso">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">fit_group_lasso</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">use_pyglm</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">y_dist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">group_lasso</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#fit_group_lasso"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.fit_group_lasso" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits cross-validated ridge on [X, Xk] and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>use_pyglm</strong><span class="classifier">bool</span></dt><dd><p>When fitting the group lasso, use the pyglm package if True (default).
Else, use the group_lasso package.</p>
</dd>
<dt><strong>y_dist</strong><span class="classifier">str</span></dt><dd><p>One of “binomial” or “gaussian”</p>
</dd>
<dt><strong>group_lasso</strong><span class="classifier">bool</span></dt><dd><p>If True, use a true group lasso. Else just use the sklearn ungrouped
lasso.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>kwargs for eventual (group) lasso model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gl</strong><span class="classifier">pyglm/sklearn/group_lasso model</span></dt><dd><p>The model fit through cross-validation; one of many types.</p>
</dd>
<dt><strong>inds</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,)</span></code>-dimensional array of indices representing the random
permutation applied to the concatenation of [X, Xk] before fitting
<code class="docutils literal notranslate"><span class="pre">gl.</span></code></p>
</dd>
<dt><strong>rev_inds</strong><span class="classifier">np.ndarray:</span></dt><dd><p>Indices which reverse the effect of <code class="docutils literal notranslate"><span class="pre">inds.</span></code> In particular, if
M is any <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2p)</span></code>-dimensional array, then <code class="docutils literal notranslate"><span class="pre">`M==M[:,</span> <span class="pre">inds][:,</span> <span class="pre">rev_inds]`</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.fit_lasso">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">fit_lasso</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">y_dist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_lars</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#fit_lasso"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.fit_lasso" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits cross-validated lasso on [X, Xk] and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix.</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>y_dist</strong><span class="classifier">str</span></dt><dd><p>One of “binomial” or “gaussian”</p>
</dd>
<dt><strong>use_lars</strong><span class="classifier">bool</span></dt><dd><p>If True, uses a LARS-based solver for Gaussian data.
If False, uses a gradient based solver (default).</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>kwargs for sklearn model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gl</strong><span class="classifier">sklearn.linear_model.LassoCV/LassoLarsCV/LogisticRegressionCV</span></dt><dd><p>The sklearn model fit through cross-validation.</p>
</dd>
<dt><strong>inds</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,)</span></code>-dimensional array of indices representing the random
permutation applied to the concatenation of [X, Xk] before fitting
<code class="docutils literal notranslate"><span class="pre">gl.</span></code></p>
</dd>
<dt><strong>rev_inds</strong><span class="classifier">np.ndarray:</span></dt><dd><p>Indices which reverse the effect of <code class="docutils literal notranslate"><span class="pre">inds.</span></code> In particular, if
M is any <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2p)</span></code>-dimensional array, then <code class="docutils literal notranslate"><span class="pre">`M==M[:,</span> <span class="pre">inds][:,</span> <span class="pre">rev_inds]`</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.fit_ridge">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">fit_ridge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">y_dist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#fit_ridge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.fit_ridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits cross-validated ridge on [X, Xk] and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
<dt><strong>y_dist</strong><span class="classifier">str</span></dt><dd><p>One of “binomial” or “gaussian”</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>kwargs for sklearn model.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gl</strong><span class="classifier">sklearn.linear_model.RidgeCV/LogisticRegressionCV</span></dt><dd><p>The sklearn model fit through cross-validation.</p>
</dd>
<dt><strong>inds</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(2p,)</span></code>-dimensional array of indices representing the random
permutation applied to the concatenation of [X, Xk] before fitting
<code class="docutils literal notranslate"><span class="pre">gl.</span></code></p>
</dd>
<dt><strong>rev_inds</strong><span class="classifier">np.ndarray:</span></dt><dd><p>Indices which reverse the effect of <code class="docutils literal notranslate"><span class="pre">inds.</span></code> In particular, if
M is any <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2p)</span></code>-dimensional array, then <code class="docutils literal notranslate"><span class="pre">`M==M[:,</span> <span class="pre">inds][:,</span> <span class="pre">rev_inds]`</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.parse_logistic_flag">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">parse_logistic_flag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#parse_logistic_flag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.parse_logistic_flag" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether y_dist is binomial</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.parse_y_dist">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">parse_y_dist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#parse_y_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.parse_y_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if y is binary; else assumes it is continuous</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoff_stats.use_reg_lasso">
<code class="sig-prename descclassname">knockpy.knockoff_stats.</code><code class="sig-name descname">use_reg_lasso</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoff_stats.html#use_reg_lasso"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoff_stats.use_reg_lasso" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses whether or not to use group lasso</p>
</dd></dl>

</div>
<div class="section" id="module-knockpy.knockoffs">
<span id="gaussian-and-fixed-x-knockoff-samplers"></span><h2>Gaussian and Fixed-X Knockoff Samplers<a class="headerlink" href="#module-knockpy.knockoffs" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="knockpy.knockoffs.FXSampler">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoffs.</code><code class="sig-name descname">FXSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">S</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#FXSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.FXSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples FX knockoffs. See the GaussianSampler documentation 
for description of the arguments.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_PSD_condition</span></code>(Sigma, S)</p></td>
<td><p>Checks that the feature-knockoff cov matrix is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_xk_validity</span></code>(X, Xk[, testname, alpha])</p></td>
<td><p>Runs a variety of KS tests on X and Xk to (informally) check that Xk are valid knockoffs for X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoffs.FXSampler.fetch_S" title="knockpy.knockoffs.FXSampler.fetch_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_S</span></code></a>()</p></td>
<td><p>Rescales S to the same scale as the initial X input</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">many_ks_tests</span></code>(sample1s, sample2s)</p></td>
<td><p>Samples1s, Sample2s = list of arrays Gets p values by running ks tests and then does a multiple testing correction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoffs.FXSampler.sample_knockoffs" title="knockpy.knockoffs.FXSampler.sample_knockoffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_knockoffs</span></code></a>()</p></td>
<td><p>Samples knockoffs.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoffs.FXSampler.fetch_S">
<code class="sig-name descname">fetch_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#FXSampler.fetch_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.FXSampler.fetch_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales S to the same scale as the initial X input</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoffs.FXSampler.sample_knockoffs">
<code class="sig-name descname">sample_knockoffs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#FXSampler.sample_knockoffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.FXSampler.sample_knockoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples knockoffs. returns n x p knockoff matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoffs.GaussianSampler">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoffs.</code><code class="sig-name descname">GaussianSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Sigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">invSigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">S</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#GaussianSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.GaussianSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples MX Gaussian (group) knockoffs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design</p>
</dd>
<dt><strong>mu</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">)</span></code>-shaped mean of the features. If None, this defaults to
the empirical mean of the features.</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of the features. If None, this
is estimated using the <code class="docutils literal notranslate"><span class="pre">utilities.estimate_covariance</span></code> function.</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to None (regular knockoffs).</p>
</dd>
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped knockoff S-matrix used to generate knockoffs. This 
is defined such that Cov(X, tilde(X)) = Sigma - S. When None,
will be constructed by knockoff generator. Defaults to None.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>Specifies how to construct S matrix. This will be ignored if <code class="docutils literal notranslate"><span class="pre">S</span></code> is not None.
There are several options:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘mvr’: Minimum Variance-Based Reconstructability knockoffs.</p></li>
<li><p>‘mmi’: Minimizes the mutual information between X and the knockoffs.</p></li>
<li><p>‘ci’: Conditional independence knockoffs.</p></li>
<li><p>‘sdp’: minimize the mean absolute covariance (MAC) between the features</p></li>
</ul>
<p>and the knockoffs.
- ‘equicorrelated’: Minimizes the MAC under the constraint that the 
the correlation between each feature and its knockoff is the same.</p>
</div></blockquote>
<p>The default is to use mvr for non-group knockoffs, and to use the group-SDP
for grouped knockoffs (the implementation for group mvr knockoffs is currently
fairly slow). In both cases we use a block-diagonal approximation 
if the number if features is greater than 1000.</p>
</dd>
<dt><strong>objective</strong><span class="classifier">str</span></dt><dd><p>How to optimize the S matrix if using the SDP for group knockoffs.
There are several options:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘abs’: minimize sum(abs(Sigma - S))</p></li>
</ul>
<p>between groups and the group knockoffs.
- ‘pnorm’: minimize Lp-th matrix norm.
Equivalent to abs when p = 1.
- ‘norm’: minimize different type of matrix norm
(see norm_type below).</p>
</div></blockquote>
</dd>
<dt><strong>sample_tol</strong><span class="classifier">float</span></dt><dd><p>Minimum eigenvalue allowed for feature-knockoff covariance 
matrix. Keep this small but nonzero (1e-5) to prevent numerical errors.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints progress over time</p>
</dd>
<dt><strong>rec_prop</strong><span class="classifier">float</span></dt><dd><p>The proportion of knockoffs to recycle (see Barber and Candes 2018,
<a class="reference external" href="https://arxiv.org/abs/1602.03574">https://arxiv.org/abs/1602.03574</a>). If method = ‘mvr’, then S_generation 
takes this into account and should increase the power of recycled knockoffs.    sparsely-correlated, high-dimensional settings.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Other kwargs for S-matrix solvers.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_PSD_condition</span></code>(Sigma, S)</p></td>
<td><p>Checks that the feature-knockoff cov matrix is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_xk_validity</span></code>(X, Xk[, testname, alpha])</p></td>
<td><p>Runs a variety of KS tests on X and Xk to (informally) check that Xk are valid knockoffs for X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoffs.GaussianSampler.fetch_S" title="knockpy.knockoffs.GaussianSampler.fetch_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_S</span></code></a>()</p></td>
<td><p>Fetches knockoff S-matrix.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">many_ks_tests</span></code>(sample1s, sample2s)</p></td>
<td><p>Samples1s, Sample2s = list of arrays Gets p values by running ks tests and then does a multiple testing correction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoffs.GaussianSampler.sample_knockoffs" title="knockpy.knockoffs.GaussianSampler.sample_knockoffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_knockoffs</span></code></a>()</p></td>
<td><p>Samples knockoffs.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoffs.GaussianSampler.fetch_S">
<code class="sig-name descname">fetch_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#GaussianSampler.fetch_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.GaussianSampler.fetch_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches knockoff S-matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoffs.GaussianSampler.sample_knockoffs">
<code class="sig-name descname">sample_knockoffs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#GaussianSampler.sample_knockoffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.GaussianSampler.sample_knockoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples knockoffs. returns n x p knockoff matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.knockoffs.KnockoffSampler">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.knockoffs.</code><code class="sig-name descname">KnockoffSampler</code><a class="reference internal" href="_modules/knockpy/knockoffs.html#KnockoffSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.KnockoffSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for sampling knockoffs.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoffs.KnockoffSampler.check_PSD_condition" title="knockpy.knockoffs.KnockoffSampler.check_PSD_condition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_PSD_condition</span></code></a>(Sigma, S)</p></td>
<td><p>Checks that the feature-knockoff cov matrix is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoffs.KnockoffSampler.check_xk_validity" title="knockpy.knockoffs.KnockoffSampler.check_xk_validity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_xk_validity</span></code></a>(X, Xk[, testname, alpha])</p></td>
<td><p>Runs a variety of KS tests on X and Xk to (informally) check that Xk are valid knockoffs for X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.knockoffs.KnockoffSampler.fetch_S" title="knockpy.knockoffs.KnockoffSampler.fetch_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_S</span></code></a>()</p></td>
<td><p>Fetches knockoff S-matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.knockoffs.KnockoffSampler.many_ks_tests" title="knockpy.knockoffs.KnockoffSampler.many_ks_tests"><code class="xref py py-obj docutils literal notranslate"><span class="pre">many_ks_tests</span></code></a>(sample1s, sample2s)</p></td>
<td><p>Samples1s, Sample2s = list of arrays Gets p values by running ks tests and then does a multiple testing correction.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 67%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>sample_knockoffs</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.knockoffs.KnockoffSampler.check_PSD_condition">
<code class="sig-name descname">check_PSD_condition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">S</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#KnockoffSampler.check_PSD_condition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.KnockoffSampler.check_PSD_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the feature-knockoff cov matrix is PSD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of the features. If None, this
is estimated using the <code class="docutils literal notranslate"><span class="pre">shrinkage</span></code> option. This is ignored for
fixed-X knockoffs.</p>
</dd>
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped knockoff S-matrix used to generate knockoffs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>Raises an error if S is not PSD or 2 Sigma - S is not PSD.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoffs.KnockoffSampler.check_xk_validity">
<code class="sig-name descname">check_xk_validity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xk</span></em>, <em class="sig-param"><span class="n">testname</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">alpha</span><span class="o">=</span><span class="default_value">0.001</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#KnockoffSampler.check_xk_validity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.KnockoffSampler.check_xk_validity" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs a variety of KS tests on X and Xk to (informally)
check that Xk are valid knockoffs for X.  Uses the BHQ
adjustment for multiple testing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>testname</strong><span class="classifier">str</span></dt><dd><p>a testname that shows up in the error</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The significance level. Defaults to 0.001</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoffs.KnockoffSampler.fetch_S">
<code class="sig-name descname">fetch_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#KnockoffSampler.fetch_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.KnockoffSampler.fetch_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches knockoff S-matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.knockoffs.KnockoffSampler.many_ks_tests">
<code class="sig-name descname">many_ks_tests</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sample1s</span></em>, <em class="sig-param"><span class="n">sample2s</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#KnockoffSampler.many_ks_tests"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.KnockoffSampler.many_ks_tests" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples1s, Sample2s = list of arrays
Gets p values by running ks tests and then
does a multiple testing correction.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="knockpy.knockoffs.produce_FX_knockoffs">
<code class="sig-prename descclassname">knockpy.knockoffs.</code><code class="sig-name descname">produce_FX_knockoffs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">invSigma</span></em>, <em class="sig-param"><span class="n">S</span></em>, <em class="sig-param"><span class="n">copies</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/knockoffs.html#produce_FX_knockoffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.knockoffs.produce_FX_knockoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>See equation (1.4) of <a class="reference external" href="https://arxiv.org/pdf/1404.5609.pdf">https://arxiv.org/pdf/1404.5609.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="module-knockpy.metro">
<span id="metropolized-samplers"></span><h2>Metropolized Samplers<a class="headerlink" href="#module-knockpy.metro" title="Permalink to this headline">¶</a></h2>
<p>The metropolized knockoff sampler for an arbitrary probability density
and graphical structure using covariance-guided proposals.</p>
<p>See <a class="reference external" href="https://arxiv.org/abs/1903.00434">https://arxiv.org/abs/1903.00434</a> for a description of the algorithm
and proof of validity and runtime.</p>
<p>This code was based on initial code written by Stephen Bates in October
2019, which was released in combination with <a class="reference external" href="https://arxiv.org/abs/1903.00434">https://arxiv.org/abs/1903.00434</a>.</p>
<dl class="py class">
<dt id="knockpy.metro.ARTKSampler">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">ARTKSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">df_t</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#ARTKSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.ARTKSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples knockoffs for autoregressive T-distributed designs.
(Hence, ARTK). See <a class="reference external" href="https://arxiv.org/pdf/1903.00434.pdf">https://arxiv.org/pdf/1903.00434.pdf</a>
for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of the features. The first
diagonal should be the pairwise correlations which define the
Markov chain.</p>
</dd>
<dt><strong>df_t</strong><span class="classifier">float</span></dt><dd><p>The degrees of freedom for the t-distributions.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>kwargs to pass to the constructor method of the generic
<code class="docutils literal notranslate"><span class="pre">MetropolizedKnockoffSampler</span></code> class.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_conditional_proposal_params</span></code>([verbose, …])</p></td>
<td><p>Caches some of the conditional means for Xjstar | Xtemp.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code>(M[, active_inds])</p></td>
<td><p>Centers an n x j matrix M.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_PSD_condition</span></code>(Sigma, S)</p></td>
<td><p>Checks that the feature-knockoff cov matrix is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_xk_validity</span></code>(X, Xk[, testname, alpha])</p></td>
<td><p>Runs a variety of KS tests on X and Xk to (informally) check that Xk are valid knockoffs for X.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_F</span></code>(x_flags, j)</p></td>
<td><p>Computes the F function from Page 33 pf the paper:  Pr(tildeXj=tildexj, Xjstar=xjstar | Xtemp, tildeX_{1:j-1}, Xjstar_{1:j-1}) Note that tildexj and xjstar are NOT inputs because they do NOT change during the junction tree DP process.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_acc_prob</span></code>(x_flags, j[, log_q1, …])</p></td>
<td><p>Computes acceptance probability for variable <code class="docutils literal notranslate"><span class="pre">j</span></code> given a particular rejection pattern <code class="docutils literal notranslate"><span class="pre">x_flags</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_proposal_params</span></code>(**kwargs)</p></td>
<td><p>Constructs the covariance-guided proposal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_S</span></code>()</p></td>
<td><p>Fetches knockoff S-matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_cached_proposal_params</span></code>(Xtemp, x_flags, j)</p></td>
<td><p>Same as above, but uses caching to speed up computation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_proposal_params</span></code>(X, prev_proposals)</p></td>
<td><p>Returns mean and variance of proposal j given X and previous proposals.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lf</span></code>(X)</p></td>
<td><p>Reordered likelihood function</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lf_ratio</span></code>(X, Xjstar, j)</p></td>
<td><p>Calculates the log of the likelihood ratio between two observations: X where X[:,j]  is replaced with Xjstar, divided by the likelihood of X.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">log_q12</span></code>(x_flags, j)</p></td>
<td><p>Computes q1 and q2 as specified by page 33 of the paper.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">many_ks_tests</span></code>(sample1s, sample2s)</p></td>
<td><p>Samples1s, Sample2s = list of arrays Gets p values by running ks tests and then does a multiple testing correction.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">q_ll</span></code>(Xjstar, X, prev_proposals[, cond_mean, …])</p></td>
<td><p>Calculates the log-likelihood of a proposal Xjstar given X  and the previous proposals. Xjstar : np.ndarray     <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped numpy array of values to evaluate the proposal     likelihood at. X : np.ndarray     <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped array of observed data, in the order used to     sample knockoff variables. prev_proposals : np.ndarray     <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">j-1)</span></code>-shaped array of previous proposals, in the order     used to sample knockoff variables. If None, assumes j = 0.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_knockoffs</span></code>([clip, cache])</p></td>
<td><p>Samples knockoffs using the metropolized knockoff sampler.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_proposals</span></code>(X, prev_proposals[, …])</p></td>
<td><p>Samples a continuous or discrete proposal given the design matrix and the previous proposals.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="knockpy.metro.BlockTSampler">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">BlockTSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">df_t</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#BlockTSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.BlockTSampler" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_PSD_condition</span></code>(Sigma, S)</p></td>
<td><p>Checks that the feature-knockoff cov matrix is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_xk_validity</span></code>(X, Xk[, testname, alpha])</p></td>
<td><p>Runs a variety of KS tests on X and Xk to (informally) check that Xk are valid knockoffs for X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.BlockTSampler.fetch_S" title="knockpy.metro.BlockTSampler.fetch_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_S</span></code></a>()</p></td>
<td><p>Fetches knockoff S-matrix.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">many_ks_tests</span></code>(sample1s, sample2s)</p></td>
<td><p>Samples1s, Sample2s = list of arrays Gets p values by running ks tests and then does a multiple testing correction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.BlockTSampler.sample_knockoffs" title="knockpy.metro.BlockTSampler.sample_knockoffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_knockoffs</span></code></a>(**kwargs)</p></td>
<td><p>Actually samples knockoffs sequentially for each block.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.metro.BlockTSampler.fetch_S">
<code class="sig-name descname">fetch_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#BlockTSampler.fetch_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.BlockTSampler.fetch_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches knockoff S-matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.BlockTSampler.sample_knockoffs">
<code class="sig-name descname">sample_knockoffs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#BlockTSampler.sample_knockoffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.BlockTSampler.sample_knockoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Actually samples knockoffs sequentially for each block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>kwargs for the <code class="docutils literal notranslate"><span class="pre">MetropolizedKnockoffSampler.sample_knockoffs</span></code>
call for each block.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped knockoff matrix in the original order 
the variables were passed in.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.metro.GibbsGridSampler">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">GibbsGridSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">gibbs_graph</span></em>, <em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">Q</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_width</span><span class="o">=</span><span class="default_value">6</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#GibbsGridSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.GibbsGridSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples knockoffs for a discrete gibbs grid using the divide-and-conquer
algorithm plus metropolized knockoff sampling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>gibbs_graph</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped matrix specifying the distribution
of the gibbs grid: see <code class="docutils literal notranslate"><span class="pre">knockpy.dgp.sample_gibbs</span></code>.
This must correspond to a grid-like undirected graphical
model.</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped estimated covariance matrix of the data.</p>
</dd>
<dt><strong>max_width</strong><span class="classifier">int</span></dt><dd><p>The maximum treewidth to allow in the divide-and-conquer
algorithm.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Unlike the attributes of a <code class="docutils literal notranslate"><span class="pre">MetropolizedKnockoffSampler</span></code> class,
the attributes of a <code class="docutils literal notranslate"><span class="pre">BlockTSampler</span></code> class are stored in the same
order that the design matrix is initially passed in. E.g., <code class="docutils literal notranslate"><span class="pre">self.Xk</span></code>
corresponds with <code class="docutils literal notranslate"><span class="pre">self.X</span></code>.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_PSD_condition</span></code>(Sigma, S)</p></td>
<td><p>Checks that the feature-knockoff cov matrix is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_xk_validity</span></code>(X, Xk[, testname, alpha])</p></td>
<td><p>Runs a variety of KS tests on X and Xk to (informally) check that Xk are valid knockoffs for X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.GibbsGridSampler.fetch_S" title="knockpy.metro.GibbsGridSampler.fetch_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_S</span></code></a>()</p></td>
<td><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> because the divide-and-conquer approach means there is no one S-matrix.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">many_ks_tests</span></code>(sample1s, sample2s)</p></td>
<td><p>Samples1s, Sample2s = list of arrays Gets p values by running ks tests and then does a multiple testing correction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.GibbsGridSampler.sample_knockoffs" title="knockpy.metro.GibbsGridSampler.sample_knockoffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_knockoffs</span></code></a>(**kwargs)</p></td>
<td><p>Samples knockoffs using divide-and-conquer approach.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 58%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>coords2num</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>num2coords</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.metro.GibbsGridSampler.fetch_S">
<code class="sig-name descname">fetch_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#GibbsGridSampler.fetch_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.GibbsGridSampler.fetch_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> because the divide-and-conquer approach means
there is no one S-matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.GibbsGridSampler.sample_knockoffs">
<code class="sig-name descname">sample_knockoffs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#GibbsGridSampler.sample_knockoffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.GibbsGridSampler.sample_knockoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples knockoffs using divide-and-conquer approach.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword args for <code class="docutils literal notranslate"><span class="pre">MetropolizedKnockoffSampler.sample_knockoffs</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped knockoff matrix in the original order 
the variables were passed in.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.metro.MetropolizedKnockoffSampler">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">MetropolizedKnockoffSampler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lf</span></em>, <em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Sigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">undir_graph</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">active_frontier</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">gamma</span><span class="o">=</span><span class="default_value">0.999</span></em>, <em class="sig-param"><span class="n">metro_verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">cliques</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_potentials</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">buckets</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>A metropolized knockoff sampler for arbitrary random variables
using covariance-guided proposals.</p>
<p>Group knockoffs are not yet supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lf</strong><span class="classifier">function</span></dt><dd><p>log-probability density. This function should take a <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped
numpy array (n independent samples of a p-dimensional vector) and return
a <code class="docutils literal notranslate"><span class="pre">(n,)</span></code> shaped array of log-probabilities. This can also be supplied 
as <code class="docutils literal notranslate"><span class="pre">None</span></code> if cliques and log-potentials are supplied.</p>
</dd>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped matrix of knockoffs</p>
</dd>
<dt><strong>mu</strong><span class="classifier">np.ndarray</span></dt><dd><p>The (estimated) mean of X. Exact FDR control is maintained
even when this vector is incorrect. Defaults to the mean of X,
e.g., <code class="docutils literal notranslate"><span class="pre">X.mean(axis=0)</span></code>.</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of the features. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, this
is estimated using the data using a naive method to ensure compatability
with the proposals. Exact FDR control is maintained even when Sigma 
is incorrect.</p>
</dd>
<dt><strong>undir_graph</strong><span class="classifier">np.ndarray or nx.Graph</span></dt><dd><p>An undirected graph specifying the conditional independence
structure of the data-generating process. This must be specified 
if either of the <code class="docutils literal notranslate"><span class="pre">order</span></code> or <code class="docutils literal notranslate"><span class="pre">active_frontier</span></code> params
are not specified. One of two options:
- A networkx undirected graph object
- A <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped numpy array, where nonzero elements represent edges.</p>
</dd>
<dt><strong>order</strong><span class="classifier">np.ndarray</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">p</span></code>-length numpy array specifying the ordering to sample the variables.
Should be a vector with unique entries 0,…,p-1.</p>
</dd>
<dt><strong>active_fontier</strong><span class="classifier">A list of lists of length p where entry j is the set of</span></dt><dd><p>entries &gt; j that are in V_j. This specifies the conditional independence 
structure of the distribution given by lf. See page 34 of the paper.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>A tuning parameter to increase / decrease the acceptance ratio.
See appendix F.2. Defaults to 0.999.</p>
</dd>
<dt><strong>buckets</strong><span class="classifier">np.ndarray or list</span></dt><dd><p>A list or array of discrete values that X can take.
Covariance-guided proposals will be rounded to these values. 
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, Metro assumes the domain of each feature is all
real numbers.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>kwargs to pass to the <code class="docutils literal notranslate"><span class="pre">smatrix.compute_smatrix</span></code> method for 
sampling proposals.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>All attributes of the MetropolizedKnockoffSampler are stored in the 
order that knockoffs are sampled, NOT the order that variables are 
initially passed in. For example, the <code class="docutils literal notranslate"><span class="pre">X</span></code> attribute will not necessarily
equal the <code class="docutils literal notranslate"><span class="pre">X</span></code> argument: instead, <code class="docutils literal notranslate"><span class="pre">self.X</span> <span class="pre">=</span> <span class="pre">X[:,</span> <span class="pre">self.order]</span></code>. To reorder
attributes to the initial order of the <code class="docutils literal notranslate"><span class="pre">X</span></code> argument,
use the syntax <code class="docutils literal notranslate"><span class="pre">self.attribute[:,</span> <span class="pre">self.inv_order]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped array of indices which reorders <code class="docutils literal notranslate"><span class="pre">X</span></code> into the
order for sampling knockoffs.</p>
</dd>
<dt><strong>inv_order</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped array of indices which takes a set of variables
which have been reordered for metropolized sampling and returns
them to their initial order. For example,
<code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">==</span> <span class="pre">X[:,</span> <span class="pre">self.order][:,</span> <span class="pre">self.inv_order]</span></code>.</p>
</dd>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code> design matrix reordered according to the order for
sampling knockoffs</p>
</dd>
<dt><strong>X_prop</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped array of knockoff proposals</p>
</dd>
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped array of knockoffs</p>
</dd>
<dt><strong>acceptances</strong><span class="classifier">np.ndarray</span></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped boolean array where <code class="docutils literal notranslate"><span class="pre">acceptances[i,</span> <span class="pre">j]</span> <span class="pre">==</span> <span class="pre">1</span></code>
indicates that <code class="docutils literal notranslate"><span class="pre">X_prop[i,</span> <span class="pre">j]</span></code> was accepted.</p>
</dd>
<dt><strong>final_acc_probs</strong><span class="classifier">np.ndarray</span></dt><dd><p>a <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped array where <code class="docutils literal notranslate"><span class="pre">final_acc_probs[i,</span> <span class="pre">j]</span></code> is the 
acceptance probability for <code class="docutils literal notranslate"><span class="pre">X_prop[i,</span> <span class="pre">j]</span></code>.</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped estimated covariance matrix of <code class="docutils literal notranslate"><span class="pre">X</span></code>. The 
class constructor guarantees this is compatible with the conditional
independence structure of the data.</p>
</dd>
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped knockoff S-matrix used to generate the
covariance-guided proposals.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.cache_conditional_proposal_params" title="knockpy.metro.MetropolizedKnockoffSampler.cache_conditional_proposal_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cache_conditional_proposal_params</span></code></a>([verbose, …])</p></td>
<td><p>Caches some of the conditional means for Xjstar | Xtemp.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.center" title="knockpy.metro.MetropolizedKnockoffSampler.center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code></a>(M[, active_inds])</p></td>
<td><p>Centers an n x j matrix M.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_PSD_condition</span></code>(Sigma, S)</p></td>
<td><p>Checks that the feature-knockoff cov matrix is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_xk_validity</span></code>(X, Xk[, testname, alpha])</p></td>
<td><p>Runs a variety of KS tests on X and Xk to (informally) check that Xk are valid knockoffs for X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.compute_F" title="knockpy.metro.MetropolizedKnockoffSampler.compute_F"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_F</span></code></a>(x_flags, j)</p></td>
<td><p>Computes the F function from Page 33 pf the paper:  Pr(tildeXj=tildexj, Xjstar=xjstar | Xtemp, tildeX_{1:j-1}, Xjstar_{1:j-1}) Note that tildexj and xjstar are NOT inputs because they do NOT change during the junction tree DP process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.compute_acc_prob" title="knockpy.metro.MetropolizedKnockoffSampler.compute_acc_prob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_acc_prob</span></code></a>(x_flags, j[, log_q1, …])</p></td>
<td><p>Computes acceptance probability for variable <code class="docutils literal notranslate"><span class="pre">j</span></code> given a particular rejection pattern <code class="docutils literal notranslate"><span class="pre">x_flags</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.create_proposal_params" title="knockpy.metro.MetropolizedKnockoffSampler.create_proposal_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_proposal_params</span></code></a>(**kwargs)</p></td>
<td><p>Constructs the covariance-guided proposal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.fetch_S" title="knockpy.metro.MetropolizedKnockoffSampler.fetch_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_S</span></code></a>()</p></td>
<td><p>Fetches knockoff S-matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.fetch_cached_proposal_params" title="knockpy.metro.MetropolizedKnockoffSampler.fetch_cached_proposal_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_cached_proposal_params</span></code></a>(Xtemp, x_flags, j)</p></td>
<td><p>Same as above, but uses caching to speed up computation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.fetch_proposal_params" title="knockpy.metro.MetropolizedKnockoffSampler.fetch_proposal_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_proposal_params</span></code></a>(X, prev_proposals)</p></td>
<td><p>Returns mean and variance of proposal j given X and previous proposals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.lf" title="knockpy.metro.MetropolizedKnockoffSampler.lf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lf</span></code></a>(X)</p></td>
<td><p>Reordered likelihood function</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.lf_ratio" title="knockpy.metro.MetropolizedKnockoffSampler.lf_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lf_ratio</span></code></a>(X, Xjstar, j)</p></td>
<td><p>Calculates the log of the likelihood ratio between two observations: X where X[:,j]  is replaced with Xjstar, divided by the likelihood of X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.log_q12" title="knockpy.metro.MetropolizedKnockoffSampler.log_q12"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log_q12</span></code></a>(x_flags, j)</p></td>
<td><p>Computes q1 and q2 as specified by page 33 of the paper.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">many_ks_tests</span></code>(sample1s, sample2s)</p></td>
<td><p>Samples1s, Sample2s = list of arrays Gets p values by running ks tests and then does a multiple testing correction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.q_ll" title="knockpy.metro.MetropolizedKnockoffSampler.q_ll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">q_ll</span></code></a>(Xjstar, X, prev_proposals[, cond_mean, …])</p></td>
<td><p>Calculates the log-likelihood of a proposal Xjstar given X  and the previous proposals. Xjstar : np.ndarray     <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped numpy array of values to evaluate the proposal     likelihood at. X : np.ndarray     <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped array of observed data, in the order used to     sample knockoff variables. prev_proposals : np.ndarray     <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">j-1)</span></code>-shaped array of previous proposals, in the order     used to sample knockoff variables. If None, assumes j = 0.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.sample_knockoffs" title="knockpy.metro.MetropolizedKnockoffSampler.sample_knockoffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_knockoffs</span></code></a>([clip, cache])</p></td>
<td><p>Samples knockoffs using the metropolized knockoff sampler.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.metro.MetropolizedKnockoffSampler.sample_proposals" title="knockpy.metro.MetropolizedKnockoffSampler.sample_proposals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_proposals</span></code></a>(X, prev_proposals[, …])</p></td>
<td><p>Samples a continuous or discrete proposal given the design matrix and the previous proposals.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.cache_conditional_proposal_params">
<code class="sig-name descname">cache_conditional_proposal_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">expensive_cache</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.cache_conditional_proposal_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.cache_conditional_proposal_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Caches some of the conditional means for Xjstar | Xtemp.
If expensive_cache = True, this will be quite memory intensive
in order to achieve a 2-3x speedup. Otherwise, achieves a
a 20-30% speedup at a more modest memory cost.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.center">
<code class="sig-name descname">center</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">active_inds</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Centers an n x j matrix M. For mu = 0, does not perform
this computation, which actually is a bottleneck
for large n and p.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.compute_F">
<code class="sig-name descname">compute_F</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_flags</span></em>, <em class="sig-param"><span class="n">j</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.compute_F"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.compute_F" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the F function from Page 33 pf the paper: 
Pr(tildeXj=tildexj, Xjstar=xjstar | Xtemp, tildeX_{1:j-1}, Xjstar_{1:j-1})
Note that tildexj and xjstar are NOT inputs because they do NOT change
during the junction tree DP process.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.compute_acc_prob">
<code class="sig-name descname">compute_acc_prob</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_flags</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">log_q1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log_q2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Xtemp</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.compute_acc_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.compute_acc_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes acceptance probability for variable <code class="docutils literal notranslate"><span class="pre">j</span></code>
given a particular rejection pattern <code class="docutils literal notranslate"><span class="pre">x_flags</span></code>.</p>
<p>Mathematically, this is:
Pr(tildeXj = Xjstar | Xtemp, Xtilde_{1:j-1}, Xstar_{1:j})</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.create_proposal_params">
<code class="sig-name descname">create_proposal_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.create_proposal_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.create_proposal_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the covariance-guided proposal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>kwargs for the <code class="docutils literal notranslate"><span class="pre">smatrix.compute_smatrix</span></code> function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.fetch_S">
<code class="sig-name descname">fetch_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.fetch_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.fetch_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches knockoff S-matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.fetch_cached_proposal_params">
<code class="sig-name descname">fetch_cached_proposal_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xtemp</span></em>, <em class="sig-param"><span class="n">x_flags</span></em>, <em class="sig-param"><span class="n">j</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.fetch_cached_proposal_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.fetch_cached_proposal_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above, but uses caching to speed up computation.
This caching can be cheap (if self.cache is False) or
extremely expensive (if self.cache is True) in terms of
memory.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.fetch_proposal_params">
<code class="sig-name descname">fetch_proposal_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">prev_proposals</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.fetch_proposal_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.fetch_proposal_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns mean and variance of proposal j given X and
previous proposals. Both <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">prev_proposals</span></code>
must be in the order used to sample knockoff variables.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.lf">
<code class="sig-name descname">lf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.lf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.lf" title="Permalink to this definition">¶</a></dt>
<dd><p>Reordered likelihood function</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.lf_ratio">
<code class="sig-name descname">lf_ratio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Xjstar</span></em>, <em class="sig-param"><span class="n">j</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.lf_ratio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.lf_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log of the likelihood ratio
between two observations: X where X[:,j] 
is replaced with Xjstar, divided by the likelihood
of X. This is equivalent to (but often faster) than:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ld_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnew</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnew</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xjstar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ld_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ld_ratio</span> <span class="o">=</span> <span class="n">ld_prop</span> <span class="o">-</span> <span class="n">ld_obs</span>
</pre></div>
</div>
<p>When node potentials have been passed, this is much faster
than calculating the log-likelihood function and subtracting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – a n x p matrix of observations</p></li>
<li><p><strong>Xjstar</strong> – New observations for column j of X</p></li>
<li><p><strong>j</strong> – an int between 0 and p - 1, telling us which column to replace</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.log_q12">
<code class="sig-name descname">log_q12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_flags</span></em>, <em class="sig-param"><span class="n">j</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.log_q12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.log_q12" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes q1 and q2 as specified by page 33 of the paper.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.q_ll">
<code class="sig-name descname">q_ll</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xjstar</span></em>, <em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">prev_proposals</span></em>, <em class="sig-param"><span class="n">cond_mean</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cond_var</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.q_ll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.q_ll" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the log-likelihood of a proposal Xjstar given X 
and the previous proposals.
Xjstar : np.ndarray</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped numpy array of values to evaluate the proposal
likelihood at.</p>
</div></blockquote>
<dl class="simple">
<dt>X<span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped array of observed data, in the order used to
sample knockoff variables.</p>
</dd>
<dt>prev_proposals<span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">j-1)</span></code>-shaped array of previous proposals, in the order
used to sample knockoff variables. If None, assumes j = 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.sample_knockoffs">
<code class="sig-name descname">sample_knockoffs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clip</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">cache</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.sample_knockoffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.sample_knockoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples knockoffs using the metropolized knockoff
sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Xk</strong><span class="classifier">np.ndarray</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped knockoff matrix in the original order 
the variables were passed in.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="knockpy.metro.MetropolizedKnockoffSampler.sample_proposals">
<code class="sig-name descname">sample_proposals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">prev_proposals</span></em>, <em class="sig-param"><span class="n">cond_mean</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cond_var</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#MetropolizedKnockoffSampler.sample_proposals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.MetropolizedKnockoffSampler.sample_proposals" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples a continuous or discrete proposal given the design
matrix and the previous proposals. Can pass in the conditional
mean and variance of the new proposals, if cached, to save
computation.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="knockpy.metro.gaussian_log_likelihood">
<code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">gaussian_log_likelihood</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">mu</span></em>, <em class="sig-param"><span class="n">var</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#gaussian_log_likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.gaussian_log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Somehow this is faster than scipy</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.metro.get_ordering">
<code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">get_ordering</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">T</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#get_ordering"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.get_ordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a junction tree and returns a variable ordering for the metro
knockoff sampler. The code from this function is adapted from
the code distributed with <a class="reference external" href="https://arxiv.org/abs/1903.00434">https://arxiv.org/abs/1903.00434</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>T</strong><span class="classifier">A networkx graph that is a junction tree.</span></dt><dd></dd>
<dt><strong>Nodes must be sets with elements 0,…,p-1.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>order</strong><span class="classifier">a numpy array with unique elements 0,…,p-1</span></dt><dd></dd>
<dt><strong>active_frontier</strong><span class="classifier">list of lists</span></dt><dd><p>a list of length p gwhere entry j is the set of entries &gt; j 
that are in V_j. This specifies the conditional independence structure
of a joint covariate distribution. See page 34 of
<a class="reference external" href="https://arxiv.org/abs/1903.00434">https://arxiv.org/abs/1903.00434</a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.metro.t_log_likelihood">
<code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">t_log_likelihood</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">df_t</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#t_log_likelihood"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.t_log_likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>UNNORMALIZED t loglikelihood.
This is also faster than scipy</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.metro.t_markov_loglike">
<code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">t_markov_loglike</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">rhos</span></em>, <em class="sig-param"><span class="n">df_t</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#t_markov_loglike"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.t_markov_loglike" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates log-likelihood for markov chain
specified in <a class="reference external" href="https://arxiv.org/pdf/1903.00434.pdf">https://arxiv.org/pdf/1903.00434.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.metro.t_mvn_loglike">
<code class="sig-prename descclassname">knockpy.metro.</code><code class="sig-name descname">t_mvn_loglike</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">invScale</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">df_t</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/metro.html#t_mvn_loglike"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.metro.t_mvn_loglike" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates multivariate t log-likelihood
up to normalizing constant.
:param X: n x p array of data
:param invScale: p x p array, inverse multivariate t scale matrix
:param mu: p-length array, location parameter
:param df_t: degrees of freedom</p>
</dd></dl>

</div>
<div class="section" id="module-knockpy.smatrix">
<span id="s-matrix-computation"></span><h2>S-matrix computation<a class="headerlink" href="#module-knockpy.smatrix" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="knockpy.smatrix.compute_smatrix">
<code class="sig-prename descclassname">knockpy.smatrix.</code><code class="sig-name descname">compute_smatrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">'cd'</span></em>, <em class="sig-param"><span class="n">how_approx</span><span class="o">=</span><span class="default_value">'blockdiag'</span></em>, <em class="sig-param"><span class="n">max_block</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">num_factors</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">num_processes</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">D</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">U</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/smatrix.html#compute_smatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.smatrix.compute_smatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps a variety of S-matrix generation functions.
For mvr, maxent, mmi, and sdp methods, this can use
a block-diagonal approximation of Sigma if the dimension
of Sigma exceeds max_block or a factor approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd></dd>
<dt><strong>``(p, p)``-shaped covariance matrix of X</strong></dt><dd></dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> (regular knockoffs).</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>Method for constructing S-matrix. One of mvr, maxent, mmi, sdp, equicorrelated, ci.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str</span></dt><dd><p>Method for solving mrc knockoffs. One of ‘cd’ (coordinate descent) 
or ‘psgd’ (projected gradient descent). Coordinate descent is 
highly recommended.</p>
</dd>
<dt><strong>how_approx</strong><span class="classifier">str</span></dt><dd><p>How to approximate the covariance matrix to speed up computation. 
- If ‘blockdiag’, approximates Sigma as a block-diagonal matrix.
- If ‘factor’, approximates <code class="docutils literal notranslate"><span class="pre">Sigma</span> <span class="pre">=</span> <span class="pre">np.diag(D)</span> <span class="pre">+</span> <span class="pre">np.dot(U,</span> <span class="pre">U.T)</span></code>,
a factor model.</p>
</dd>
<dt><strong>max_block</strong><span class="classifier">int</span></dt><dd><p>The maximum size of a block if how_approx=’blockdiag’. Defaults to 1000.</p>
</dd>
<dt><strong>num_factors</strong><span class="classifier">int</span></dt><dd><p>The number of factors if how_approx=’factor’. Defaults to 20.</p>
</dd>
<dt><strong>num_processes</strong><span class="classifier">int</span></dt><dd><p>Number of parallel process to use if Sigma is approximated as
a block-diagonal matrix.</p>
</dd>
<dt><strong>D</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">p</span></code>-shaped array of diagonal elements for factor model. Only used 
if how_approx=’factor’. This is optional if Sigma is not None.</p>
</dd>
<dt><strong>U</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">k)</span></code>-shaped matrix for factor model. Usually k &lt;&lt; p. Only used 
if how_approx=’factor’. This is optional if Sigma is not None.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>kwargs to pass to one of the wrapped S-matrix solvers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>mmi stands for minimum mutual information, which is the same as maximizing
entropy.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.smatrix.compute_smatrix_factored">
<code class="sig-prename descclassname">knockpy.smatrix.</code><code class="sig-name descname">compute_smatrix_factored</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">D</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">U</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'mvr'</span></em>, <em class="sig-param"><span class="n">num_factors</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/smatrix.html#compute_smatrix_factored"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.smatrix.compute_smatrix_factored" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps S-matrix generation functions which approximate
<code class="docutils literal notranslate"><span class="pre">Sigma</span> <span class="pre">=</span> <span class="pre">np.diag(D)</span> <span class="pre">+</span> <span class="pre">np.dot(U,</span> <span class="pre">U.T)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd></dd>
<dt><strong>``(p, p)``-shaped covariance matrix of X</strong></dt><dd></dd>
<dt><strong>D</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">p</span></code>-shaped array of diagonal elements for factor model. Only used 
if how_approx=’factor’. This is optional if Sigma is not None.</p>
</dd>
<dt><strong>U</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">k)</span></code>-shaped matrix for factor model. Usually k &lt;&lt; p. Only used 
if how_approx=’factor’. This is optional if Sigma is not None.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>Method for constructing S-matrix. One of mvr, maxent, mmi.</p>
</dd>
<dt><strong>num_factors</strong><span class="classifier">int</span></dt><dd><p>The number of factors if how_approx=’factor’. Defaults to 20.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>kwargs to pass to one of the wrapped S-matrix solvers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>mmi stands for minimum mutual information, which is the same as maximizing
entropy.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.smatrix.divide_computation">
<code class="sig-prename descclassname">knockpy.smatrix.</code><code class="sig-name descname">divide_computation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">max_block</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/smatrix.html#divide_computation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.smatrix.divide_computation" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximates a correlation matrix Sigma as a block-diagonal matrix
using hierarchical clustering. Roughly follows the R knockoff package.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.smatrix.merge_groups">
<code class="sig-prename descclassname">knockpy.smatrix.</code><code class="sig-name descname">merge_groups</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">max_block</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/smatrix.html#merge_groups"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.smatrix.merge_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges groups of variables together while ensuring all new groups
have size less than max_block.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.smatrix.parse_method">
<code class="sig-prename descclassname">knockpy.smatrix.</code><code class="sig-name descname">parse_method</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span></em>, <em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/smatrix.html#parse_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.smatrix.parse_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Decides which method to use to create the knockoff S matrix</p>
</dd></dl>

<span class="target" id="module-knockpy.mrc"></span><p>Methods for minimum-reconstructability knockoffs.</p>
<dl class="py function">
<dt id="knockpy.mrc.cholupdate">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">cholupdate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">R</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">add</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#cholupdate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.cholupdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs rank one updates to a cholesky factor <cite>R</cite> in place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>R</strong><span class="classifier">np.ndarray</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">(p,p)</span></code>-shaped upper-triangular matrix.</p>
</dd>
<dt><strong>x</strong><span class="classifier">np.ndarray</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped vector.</p>
</dd>
<dt><strong>add</strong><span class="classifier">bool</span></dt><dd><p>If True, performs a rank one update; else performs a
rank one downdate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>R</strong><span class="classifier">np.ndarray</span></dt><dd><p>Suppose the parameter R was a cholesky factor of a matrix V.
Upon return, R is the cholesky factor of 
<code class="docutils literal notranslate"><span class="pre">V</span> <span class="pre">+/-</span> <span class="pre">np.outer(x,</span> <span class="pre">x)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function modifies both <code class="docutils literal notranslate"><span class="pre">R</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in place.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">choldate</span></code> package is a much faster and more</p></li>
</ul>
<p>numerically stable alternative.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.maxent_loss">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">maxent_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">S</span></em>, <em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#maxent_loss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.maxent_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log determinant of the feature-knockoff precision
matrix, which is proportional to the negative entropy of [X, tilde{X}].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped S-matrix used to generate knockoffs</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">float</span></dt><dd><p>Add <code class="docutils literal notranslate"><span class="pre">smoothing</span></code> to all eigenvalues of the feature-knockoff
precision matrix before taking the log determinant
to avoid numerical instability. Defaults to 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>loss</strong><span class="classifier">float</span></dt><dd><p>The maxent loss for Sigma and S. This is infinite if S is not feasible.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.mmi_loss">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">mmi_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#mmi_loss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.mmi_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log determinant of the feature-knockoff precision
matrix, which is proportional mutual information between X and knockoffs.</p>
<p>This is identical to <code class="docutils literal notranslate"><span class="pre">maxent_loss</span></code> and exists only for backwards 
compatability.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.mvr_loss">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">mvr_loss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">S</span></em>, <em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#mvr_loss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.mvr_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes minimum variance-based reconstructability
loss for knockoffs, e.g., the trace of the feature-knockoff
precision matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped S-matrix used to generate knockoffs</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">float</span></dt><dd><p>Add <code class="docutils literal notranslate"><span class="pre">smoothing</span></code> to all eigenvalues of the feature-knockoff
precision matrix before inverting to avoid numerical
instability. Defaults to 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>loss</strong><span class="classifier">float</span></dt><dd><p>The MVR loss for Sigma and S. This is infinite if S is not feasible.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.solve_ciknock">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">solve_ciknock</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#solve_ciknock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.solve_ciknock" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes S-matrix used to generate conditional independence
knockoffs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int</span></dt><dd><p>The number of iterations in the binary search to ensure
S is feasible.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When the S-matrix corresponding to conditional independence knockoffs
is not feasible, this computes that S matrix and then does a binary 
search to find the maximum gamma such that gamma * S is feasible.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.solve_maxent">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">solve_maxent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">converge_tol</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">choldate_warning</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#solve_maxent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.solve_maxent" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes S-matrix used to generate maximum entropy
knockoffs using coordinate descent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints updates during optimization.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int</span></dt><dd><p>The number of coordinate descent iterations. Defaults to 50.</p>
</dd>
<dt><strong>converge_tol</strong><span class="classifier">float</span></dt><dd><p>A parameter specifying the criteria for convergence.</p>
</dd>
<dt><strong>choldate_warning</strong><span class="classifier">bool</span></dt><dd><p>If True, will warn the user if choldate is not installed. 
Defaults to True</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.solve_maxent_factored">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">solve_maxent_factored</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">U</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">converge_tol</span><span class="o">=</span><span class="default_value">0.0001</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#solve_maxent_factored"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.solve_maxent_factored" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes S-matrix used to generate maximum entropy
knockoffs using coordinate descent assuming that
the covariance matrix follows a factor model.
This means Sigma = D + UU^T for a p x p diagonal matrix
D and a p x k matrix U.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>D</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">p</span></code>-shaped array of diagonal elements.</p>
</dd>
<dt><strong>U</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">k)</span></code>-shaped matrix. Usually k &lt;&lt; p.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints updates during optimization.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int</span></dt><dd><p>The number of coordinate descent iterations. Defaults to 50.</p>
</dd>
<dt><strong>converge_tol</strong><span class="classifier">float</span></dt><dd><p>A parameter specifying the criteria for convergence.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.solve_mmi">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">solve_mmi</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#solve_mmi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.solve_mmi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes S-matrix used to generate minimum mutual information
knockoffs. This is identical to <code class="docutils literal notranslate"><span class="pre">solve_maxent</span></code>
and exists only for backwards compatability.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.solve_mvr">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">solve_mvr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">rej_rate</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">converge_tol</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">choldate_warning</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#solve_mvr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.solve_mvr" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes S-matrix used to generate minimum variance-based
reconstructability knockoffs using coordinate descent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints updates during optimization.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int</span></dt><dd><p>The number of coordinate descent iterations. Defaults to 50.</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">float</span></dt><dd><p>Add <code class="docutils literal notranslate"><span class="pre">smoothing</span></code> to all eigenvalues of the feature-knockoff
precision matrix before inverting to avoid numerical
instability. Defaults to 0.</p>
</dd>
<dt><strong>converge_tol</strong><span class="classifier">float</span></dt><dd><p>A parameter specifying the criteria for convergence.</p>
</dd>
<dt><strong>choldate_warning</strong><span class="classifier">bool</span></dt><dd><p>If True, will warn the user if choldate is not installed. 
Defaults to True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.solve_mvr_factored">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">solve_mvr_factored</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">U</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">15</span></em>, <em class="sig-param"><span class="n">converge_tol</span><span class="o">=</span><span class="default_value">0.0001</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#solve_mvr_factored"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.solve_mvr_factored" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes S-matrix used to generate mvr knockoffs
using coordinate descent assuming that
the covariance matrix follows a factor model.
This means Sigma = D + UU^T for a p x p diagonal matrix
D and a p x k matrix U.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>D</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">p</span></code>-shaped array of diagonal elements.</p>
</dd>
<dt><strong>U</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">k)</span></code>-shaped matrix. Usually k &lt;&lt; p.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints updates during optimization.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int</span></dt><dd><p>The number of coordinate descent iterations. Defaults to 50.</p>
</dd>
<dt><strong>converge_tol</strong><span class="classifier">float</span></dt><dd><p>A parameter specifying the criteria for convergence.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mrc.solve_mvr_quadratic">
<code class="sig-prename descclassname">knockpy.mrc.</code><code class="sig-name descname">solve_mvr_quadratic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cn</span></em>, <em class="sig-param"><span class="n">cd</span></em>, <em class="sig-param"><span class="n">sj</span></em>, <em class="sig-param"><span class="n">i</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_eig</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">acc_rate</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mrc.html#solve_mvr_quadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mrc.solve_mvr_quadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a quadratic equation to find
the optimal updates for the MVR S-matrix
based off of cn and cd.
See <a class="reference external" href="https://arxiv.org/pdf/2011.14625.pdf">https://arxiv.org/pdf/2011.14625.pdf</a></p>
</dd></dl>

<span class="target" id="module-knockpy.mac"></span><dl class="py function">
<dt id="knockpy.mac.calc_min_group_eigenvalue">
<code class="sig-prename descclassname">knockpy.mac.</code><code class="sig-name descname">calc_min_group_eigenvalue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mac.html#calc_min_group_eigenvalue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mac.calc_min_group_eigenvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the minimum “group” eigenvalue of a covariance 
matrix Sigma: see Dai and Barber 2016. This is useful for
constructing equicorrelated (group) knockoffs.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mac.solve_SDP">
<code class="sig-prename descclassname">knockpy.mac.</code><code class="sig-name descname">solve_SDP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mac.html#solve_SDP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mac.solve_SDP" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves ungrouped SDP to create S-matrix for MAC-minimizing knockoffs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True, prints updates during optimization.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int</span></dt><dd><p>Number of iterations in a final binary search to account for
numerical errors and ensure 2Sigma - S is PSD.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped diagonal S-matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mac.solve_equicorrelated">
<code class="sig-prename descclassname">knockpy.mac.</code><code class="sig-name descname">solve_equicorrelated</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mac.html#solve_equicorrelated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mac.solve_equicorrelated" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the block diagonal matrix S using the 
equicorrelated method described by Dai and Barber 2016.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> (regular knockoffs).</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.mac.solve_group_SDP">
<code class="sig-prename descclassname">knockpy.mac.</code><code class="sig-name descname">solve_group_SDP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">objective</span><span class="o">=</span><span class="default_value">'abs'</span></em>, <em class="sig-param"><span class="n">norm_type</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">dsdp_warning</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/mac.html#solve_group_SDP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.mac.solve_group_SDP" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the MAC-minimizng SDP formulation for group knockoffs:
extends Barer and Candes 2015/ Candes et al 2018.</p>
<dl>
<dt>Sigma<span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt>groups<span class="classifier">np.ndarray</span></dt><dd><p>For group knockoffs, a p-length array of integers from 1 to 
num_groups such that <code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite>
is a member of group <cite>i</cite>. Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> (regular knockoffs).</p>
</dd>
<dt>verbose<span class="classifier">bool</span></dt><dd><p>If True, prints updates during optimization.</p>
</dd>
<dt>objective<span class="classifier">str</span></dt><dd><p>How to optimize the S matrix for group knockoffs. 
There are several options:
- ‘abs’: minimize sum(abs(Sigma - S))
- ‘pnorm’: minimize Lp-th matrix norm.
- ‘norm’: minimize different type of matrix norm
(see norm_type below).</p>
</dd>
<dt>norm_type<span class="classifier">str or int</span></dt><dd><ul class="simple">
<li><p>When objective == ‘pnorm’, a float specifying which Lp-th matrix norm</p></li>
</ul>
<p>to use. Can be any float &gt;= 1. 
- When objective == ‘norm’, can be ‘fro’, ‘nuc’, np.inf, or 1.</p>
</dd>
<dt>num_iter<span class="classifier">int</span></dt><dd><p>Number of iterations in a final binary search to account for
numerical errors and ensure 2Sigma - S is PSD.</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>Minimum permissible eigenvalue of 2Sigma - S and S.</p>
</dd>
<dt>kwargs<span class="classifier">dict</span></dt><dd><p>Keyword arguments to pass to the <code class="docutils literal notranslate"><span class="pre">cvxpy.Problem.solve()</span></code> method.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped (block) diagonal matrix used to generate knockoffs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="kpytorch">
<h2>Kpytorch<a class="headerlink" href="#kpytorch" title="Permalink to this headline">¶</a></h2>
<p>The kpytorch submodule includes a miscallaneous
set of classes and methods which rely on <code class="docutils literal notranslate"><span class="pre">pytorch</span></code>
for automatic differentation.</p>
<span class="target" id="module-knockpy.kpytorch.deeppink"></span><dl class="py class">
<dt id="knockpy.kpytorch.deeppink.DeepPinkModel">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.kpytorch.deeppink.</code><code class="sig-name descname">DeepPinkModel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">inds</span></em>, <em class="sig-param"><span class="n">rev_inds</span></em>, <em class="sig-param"><span class="n">hidden_sizes</span><span class="o">=</span><span class="default_value">[64]</span></em>, <em class="sig-param"><span class="n">y_dist</span><span class="o">=</span><span class="default_value">'gaussian'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/deeppink.html#DeepPinkModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.deeppink.DeepPinkModel" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(*input, **kwargs)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_module</span></code>(name, module)</p></td>
<td><p>Adds a child module to the current module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code>(fn)</p></td>
<td><p>Applies <code class="docutils literal notranslate"><span class="pre">fn</span></code> recursively to every submodule (as returned by <code class="docutils literal notranslate"><span class="pre">.children()</span></code>) as well as self.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">buffers</span></code>([recurse])</p></td>
<td><p>Returns an iterator over module buffers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">children</span></code>()</p></td>
<td><p>Returns an iterator over immediate children modules.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cpu</span></code>()</p></td>
<td><p>Moves all model parameters and buffers to the CPU.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cuda</span></code>([device])</p></td>
<td><p>Moves all model parameters and buffers to the GPU.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">double</span></code> datatype.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>()</p></td>
<td><p>Sets the module in evaluation mode.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extra_repr</span></code>()</p></td>
<td><p>Set the extra representation of the module</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to float datatype.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.kpytorch.deeppink.DeepPinkModel.forward" title="knockpy.kpytorch.deeppink.DeepPinkModel.forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward</span></code></a>(features)</p></td>
<td><p>NOTE: FEATURES CANNOT BE SHUFFLED</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">half</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">half</span></code> datatype.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_state_dict</span></code>(state_dict[, strict])</p></td>
<td><p>Copies parameters and buffers from <code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code> into this module and its descendants.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">modules</span></code>()</p></td>
<td><p>Returns an iterator over all modules in the network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_buffers</span></code>([prefix, recurse])</p></td>
<td><p>Returns an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_children</span></code>()</p></td>
<td><p>Returns an iterator over immediate children modules, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_modules</span></code>([memo, prefix])</p></td>
<td><p>Returns an iterator over all modules in the network, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_parameters</span></code>([prefix, recurse])</p></td>
<td><p>Returns an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameters</span></code>([recurse])</p></td>
<td><p>Returns an iterator over module parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.kpytorch.deeppink.DeepPinkModel.predict" title="knockpy.kpytorch.deeppink.DeepPinkModel.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a>(features)</p></td>
<td><p>Wraps forward method, for compatibility with sklearn classes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_backward_hook</span></code>(hook)</p></td>
<td><p>Registers a backward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_buffer</span></code>(name, tensor)</p></td>
<td><p>Adds a persistent buffer to the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_hook</span></code>(hook)</p></td>
<td><p>Registers a forward hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_pre_hook</span></code>(hook)</p></td>
<td><p>Registers a forward pre-hook on the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_parameter</span></code>(name, param)</p></td>
<td><p>Adds a parameter to the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">requires_grad_</span></code>([requires_grad])</p></td>
<td><p>Change if autograd should record operations on parameters in this module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_dict</span></code>([destination, prefix, keep_vars])</p></td>
<td><p>Returns a dictionary containing a whole state of the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to</span></code>(*args, **kwargs)</p></td>
<td><p>Moves and/or casts the parameters and buffers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">train</span></code>([mode])</p></td>
<td><p>Sets the module in training mode.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code>(dst_type)</p></td>
<td><p>Casts all parameters and buffers to <code class="xref py py-attr docutils literal notranslate"><span class="pre">dst_type</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">zero_grad</span></code>()</p></td>
<td><p>Sets gradients of all model parameters to zero.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Z_regularizer</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>feature_importances</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>l1norm</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>l2norm</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>normalize_Z_weight</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>share_memory</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.kpytorch.deeppink.DeepPinkModel.forward">
<code class="sig-name descname">forward</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">features</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/deeppink.html#DeepPinkModel.forward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.deeppink.DeepPinkModel.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>NOTE: FEATURES CANNOT BE SHUFFLED</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.kpytorch.deeppink.DeepPinkModel.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">features</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/deeppink.html#DeepPinkModel.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.deeppink.DeepPinkModel.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps forward method, for compatibility
with sklearn classes.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-knockpy.kpytorch.mrcgrad"></span><p>Gradient-based methods for solving MRC problems.
Currently only used for group-knockoffs.</p>
<dl class="py class">
<dt id="knockpy.kpytorch.mrcgrad.MVRLoss">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.kpytorch.mrcgrad.</code><code class="sig-name descname">MVRLoss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">init_S</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">invSigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rec_prop</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">min_smoothing</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'mvr'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#MVRLoss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.MVRLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>A pytorch class to compute S-matrices for 
(gaussian) MX knockoffs which minimizes the 
trace of the feature-knockoff precision matrix
(the inverse of the feature-knockoff 
covariance/Grahm matrix, G).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Sigma</strong> – p x p numpy matrix. Must already</p>
</dd>
</dl>
<p>be sorted by groups.
:param groups: p length numpy array of groups. 
These must already be sorted and correspond to 
the Sigma.
:param init_S: The initialization values for the S
block-diagonal matrix. 
- A p x p matrix. The block-diagonal of this matrix,
as specified by groups, will be the initial values 
for the S matrix.
- A list of square numpy matrices, with the ith element
corresponding to the block of the ith group in S.
Default: Half of the identity.
:param rec_prop: The proportion of data you are planning
to recycle. (The optimal S matrix depends on the recycling
proportion.)
:param rec_prop: The proportion of knockoffs that will be
recycled.
:param smoothing: Calculate the loss as sum 1/(eigs + smoothing)
as opposed to sum 1/eigs. This is helpful if fitting lasso 
statistics on extremely degenerate covariance matrices. Over the 
course of optimization, this smoothing parameter will go to 0.
:param method: One of mvr or maxent (mmi for backwards compatability).</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(*input, **kwargs)</p></td>
<td><p>Call self as a function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_module</span></code>(name, module)</p></td>
<td><p>Adds a child module to the current module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code>(fn)</p></td>
<td><p>Applies <code class="docutils literal notranslate"><span class="pre">fn</span></code> recursively to every submodule (as returned by <code class="docutils literal notranslate"><span class="pre">.children()</span></code>) as well as self.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">buffers</span></code>([recurse])</p></td>
<td><p>Returns an iterator over module buffers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">children</span></code>()</p></td>
<td><p>Returns an iterator over immediate children modules.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cpu</span></code>()</p></td>
<td><p>Moves all model parameters and buffers to the CPU.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cuda</span></code>([device])</p></td>
<td><p>Moves all model parameters and buffers to the GPU.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">double</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">double</span></code> datatype.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>()</p></td>
<td><p>Sets the module in evaluation mode.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extra_repr</span></code>()</p></td>
<td><p>Set the extra representation of the module</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to float datatype.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.kpytorch.mrcgrad.MVRLoss.forward" title="knockpy.kpytorch.mrcgrad.MVRLoss.forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">forward</span></code></a>([smoothing])</p></td>
<td><p>Calculates trace of inverse grahm feature-knockoff matrix</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">half</span></code>()</p></td>
<td><p>Casts all floating point parameters and buffers to <code class="docutils literal notranslate"><span class="pre">half</span></code> datatype.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_state_dict</span></code>(state_dict[, strict])</p></td>
<td><p>Copies parameters and buffers from <code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code> into this module and its descendants.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">modules</span></code>()</p></td>
<td><p>Returns an iterator over all modules in the network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_buffers</span></code>([prefix, recurse])</p></td>
<td><p>Returns an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_children</span></code>()</p></td>
<td><p>Returns an iterator over immediate children modules, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_modules</span></code>([memo, prefix])</p></td>
<td><p>Returns an iterator over all modules in the network, yielding both the name of the module as well as the module itself.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">named_parameters</span></code>([prefix, recurse])</p></td>
<td><p>Returns an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameters</span></code>([recurse])</p></td>
<td><p>Returns an iterator over module parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.kpytorch.mrcgrad.MVRLoss.project" title="knockpy.kpytorch.mrcgrad.MVRLoss.project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code></a>(**kwargs)</p></td>
<td><p>Project by scaling sqrt_S</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.kpytorch.mrcgrad.MVRLoss.pull_S" title="knockpy.kpytorch.mrcgrad.MVRLoss.pull_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pull_S</span></code></a>()</p></td>
<td><p>Returns the S matrix</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_backward_hook</span></code>(hook)</p></td>
<td><p>Registers a backward hook on the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_buffer</span></code>(name, tensor)</p></td>
<td><p>Adds a persistent buffer to the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_hook</span></code>(hook)</p></td>
<td><p>Registers a forward hook on the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_forward_pre_hook</span></code>(hook)</p></td>
<td><p>Registers a forward pre-hook on the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_parameter</span></code>(name, param)</p></td>
<td><p>Adds a parameter to the module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">requires_grad_</span></code>([requires_grad])</p></td>
<td><p>Change if autograd should record operations on parameters in this module.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.kpytorch.mrcgrad.MVRLoss.scale_sqrt_S" title="knockpy.kpytorch.mrcgrad.MVRLoss.scale_sqrt_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_sqrt_S</span></code></a>(tol, num_iter)</p></td>
<td><p>Scales sqrt_S such that 2 Sigma - S is PSD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_dict</span></code>([destination, prefix, keep_vars])</p></td>
<td><p>Returns a dictionary containing a whole state of the module.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to</span></code>(*args, **kwargs)</p></td>
<td><p>Moves and/or casts the parameters and buffers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">train</span></code>([mode])</p></td>
<td><p>Sets the module in training mode.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code>(dst_type)</p></td>
<td><p>Casts all parameters and buffers to <code class="xref py py-attr docutils literal notranslate"><span class="pre">dst_type</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#knockpy.kpytorch.mrcgrad.MVRLoss.update_sqrt_S" title="knockpy.kpytorch.mrcgrad.MVRLoss.update_sqrt_S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_sqrt_S</span></code></a>()</p></td>
<td><p>Updates sqrt_S using the block parameters</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">zero_grad</span></code>()</p></td>
<td><p>Sets gradients of all model parameters to zero.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>share_memory</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.kpytorch.mrcgrad.MVRLoss.forward">
<code class="sig-name descname">forward</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#MVRLoss.forward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.MVRLoss.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates trace of inverse grahm feature-knockoff matrix</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.kpytorch.mrcgrad.MVRLoss.project">
<code class="sig-name descname">project</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#MVRLoss.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.MVRLoss.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project by scaling sqrt_S</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.kpytorch.mrcgrad.MVRLoss.pull_S">
<code class="sig-name descname">pull_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#MVRLoss.pull_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.MVRLoss.pull_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the S matrix</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.kpytorch.mrcgrad.MVRLoss.scale_sqrt_S">
<code class="sig-name descname">scale_sqrt_S</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tol</span></em>, <em class="sig-param"><span class="n">num_iter</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#MVRLoss.scale_sqrt_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.MVRLoss.scale_sqrt_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales sqrt_S such that 2 Sigma - S is PSD.</p>
</dd></dl>

<dl class="py method">
<dt id="knockpy.kpytorch.mrcgrad.MVRLoss.update_sqrt_S">
<code class="sig-name descname">update_sqrt_S</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#MVRLoss.update_sqrt_S"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.MVRLoss.update_sqrt_S" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates sqrt_S using the block parameters</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="knockpy.kpytorch.mrcgrad.PSGDSolver">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.kpytorch.mrcgrad.</code><code class="sig-name descname">PSGDSolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">groups</span></em>, <em class="sig-param"><span class="n">losscalc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lr</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_epochs</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">line_search_iter</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">convergence_tol</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#PSGDSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.PSGDSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Projected gradient descent to solve for MRC knockoffs.
This will work for non-convex loss objectives as well,
although it’s a heuristic optimization method.
:param Sigma: p x p numpy array, the correlation matrix
:param groups: p-length numpy array specifying groups
:param losscalc: A pytorch class wrapping nn.module
which contains the following methods:
- .forward() which calculates the loss based on the
internally stored S matrix.
- .project() which ensures that both the internally-stored
S matrix as well as (2*Sigma - S) are PSD.
- .pull_S(), which returns the internally-stored S matrix.
If None, creates a MVRLoss class. 
:param lr: Initial learning rate (default 1e-2)
:param verbose: if true, reports progress
:param max_epochs: Maximum number of epochs in SGD
:param tol: Mimimum eigenvalue allowed for PSD matrices
:param line_search_iter: Number of line searches to do
when scaling sqrt_S.
:param convergence_tol: After each projection, we calculate
improvement = 2/3 * ||prev_opt_S - opt_S||_1 + 1/3 * (improvement)
When improvement &lt; convergence_tol, we return.
:param kwargs: Passed to MVRLoss</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.kpytorch.mrcgrad.PSGDSolver.optimize" title="knockpy.kpytorch.mrcgrad.PSGDSolver.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize</span></code></a>()</p></td>
<td><p>See __init__ for arguments.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 52%" />
<col style="width: 48%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>cache_S</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.kpytorch.mrcgrad.PSGDSolver.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#PSGDSolver.optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.PSGDSolver.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>See __init__ for arguments.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="knockpy.kpytorch.mrcgrad.block_diag_sparse">
<code class="sig-prename descclassname">knockpy.kpytorch.mrcgrad.</code><code class="sig-name descname">block_diag_sparse</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">arrs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#block_diag_sparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.block_diag_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of 2D torch tensors, creates a sparse block-diagonal matrix
See <a class="reference external" href="https://github.com/pytorch/pytorch/issues/31942">https://github.com/pytorch/pytorch/issues/31942</a></p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.kpytorch.mrcgrad.solve_mrc_psgd">
<code class="sig-prename descclassname">knockpy.kpytorch.mrcgrad.</code><code class="sig-name descname">solve_mrc_psgd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'mvr'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/kpytorch/mrcgrad.html#solve_mrc_psgd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.kpytorch.mrcgrad.solve_mrc_psgd" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the PSGDSolver class.
:param Sigma: Covariance matrix
:param groups: groups for group knockoffs
:param method: MRC loss (mvr or maxent)
:param init_kwargs: kwargs to pass to 
PSGDSolver.
:param optimize_kwargs: kwargs to pass 
to optimizer method.
:returns: opt_S</p>
</dd></dl>

</div>
<div class="section" id="module-knockpy.dgp">
<span id="quickly-creating-data-generating-processes"></span><h2>Quickly creating data-generating processes<a class="headerlink" href="#module-knockpy.dgp" title="Permalink to this headline">¶</a></h2>
<p>A collection of functions for generating synthetic datasets.</p>
<dl class="py function">
<dt id="knockpy.dgp.AR1">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">AR1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">a</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#AR1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.AR1" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates <cite>p</cite>-dimensional correlation matrix for
AR(1) Gaussian process, where successive correlations
are drawn from Beta(<cite>a</cite>,`b`) independelty. If <cite>rho</cite> is
specified, then the process is stationary with correlation
<cite>rho</cite>.</p>
</dd></dl>

<dl class="py class">
<dt id="knockpy.dgp.DGP">
<em class="property">class </em><code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">DGP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">Sigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">invSigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">gibbs_graph</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#DGP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.DGP" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility class which creates a (random) data-generating process 
for a design matrix X and a response y. If the parameters are
not specified, they will be randomly generated during the
<code class="docutils literal notranslate"><span class="pre">sample_data</span></code> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped mean vector for X data</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix for X data</p>
</dd>
<dt><strong>invSigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped precision matrix for X data</p>
</dd>
<dt><strong>beta</strong><span class="classifier">np.ndarray</span></dt><dd><p>coefficients used to generate y from X in a single 
index or sparse additive model.</p>
</dd>
<dt><strong>gibbs_graph</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped matrix of coefficients for gibbs
grid method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">np.ndarray</span></dt><dd><p>See above</p>
</dd>
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p>See above</p>
</dd>
<dt><strong>invSigma</strong><span class="classifier">np.ndarray</span></dt><dd><p>See above</p>
</dd>
<dt><strong>beta</strong><span class="classifier">np.ndarray</span></dt><dd><p>See above</p>
</dd>
<dt><strong>gibbs_Graph</strong><span class="classifier">np.ndarray</span></dt><dd><p>See above</p>
</dd>
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">)</span></code>-shaped response vector</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#knockpy.dgp.DGP.sample_data" title="knockpy.dgp.DGP.sample_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_data</span></code></a>([p, n, x_dist, method, y_dist, …])</p></td>
<td><p>(Possibly) generates random data-generating parameters and then samples data using those parameters.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="knockpy.dgp.DGP.sample_data">
<code class="sig-name descname">sample_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">x_dist</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'AR1'</span></em>, <em class="sig-param"><span class="n">y_dist</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">cond_mean</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">coeff_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">coeff_dist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sparsity</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sign_prob</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">iid_signs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">corr_signals</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">df_t</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#DGP.sample_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.DGP.sample_data" title="Permalink to this definition">¶</a></dt>
<dd><p>(Possibly) generates random data-generating parameters
and then samples data using those parameters. By default,
(X, y) are jointly Gaussian and y is a linear response to
X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of data points</p>
</dd>
<dt><strong>p</strong><span class="classifier">int</span></dt><dd><p>The dimensionality of the data</p>
</dd>
<dt><strong>x_dist</strong><span class="classifier">str</span></dt><dd><p>Specifies the distribution of X. One of “Gaussian”, “blockt”, “ar1t”, or “gibbs”.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>How to generate the covariance matrix of X. One of
“AR1”, “NestedAR1”, “partialcorr”, “factor”, 
“blockequi”, “ver”, “qer”, “dirichlet”, or “uniformdot”.
See the docs for each of these methods.</p>
</dd>
<dt><strong>y_dist</strong><span class="classifier">str</span></dt><dd><p>Specifies the distribution of y. One of “Gaussian” or “binomial”.</p>
</dd>
<dt><strong>cond_mean</strong><span class="classifier">str</span></dt><dd><p>How to calculate the conditional mean of y given X. Defaults to 
“linear”. See <code class="docutils literal notranslate"><span class="pre">knockpy.dgp.sample_response</span></code> for more options.</p>
</dd>
<dt><strong>coeff_size: float</strong></dt><dd><p>Size of non-zero coefficients</p>
</dd>
<dt><strong>coeff_dist</strong><span class="classifier">str</span></dt><dd><p>Specifies the distribution of nonzero coefficients. Three options:
- <code class="docutils literal notranslate"><span class="pre">None</span></code>: all coefficients have absolute value coeff_size.
- <code class="docutils literal notranslate"><span class="pre">normal</span></code>: all nonzero coefficients are drawn from Normal(coeff_size, 1). 
- <code class="docutils literal notranslate"><span class="pre">uniform</span></code>: nonzero coeffs are drawn from Unif(coeff_size/2, coeff_size).</p>
</dd>
<dt><strong>sparsity</strong><span class="classifier">float</span></dt><dd><p>Proportion of non-null coefficients. 
Generates <code class="docutils literal notranslate"><span class="pre">np.floor(p*sparsity)</span></code> non-nulls.</p>
</dd>
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p>A p-length array of integers from 1 to num_groups such that
<code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite> is a member of group <cite>i</cite>.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>. Else, floor(sparsity * num_groups) groups will be 
chosen to be non-null, where all elements of each group are non-null.</p>
</dd>
<dt><strong>sign_prob</strong><span class="classifier">float</span></dt><dd><p>The probability that each nonzero coefficient will be positive.</p>
</dd>
<dt><strong>iid_signs</strong><span class="classifier">bool</span></dt><dd><p>If True, the signs of the coeffs are assigned independently.
Else, exactly sign_prob*sparsity*p coefficients will be positive.</p>
</dd>
<dt><strong>corr_signals</strong><span class="classifier">bool</span></dt><dd><p>If true, all of the nonzero coefficients will lie in a consecutive block.</p>
</dd>
<dt><strong>df_t</strong><span class="classifier">float</span></dt><dd><p>If the X variables are marginally t-distributed, the degrees of freedom.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>keyword arguments to pass to method for generating the covariance matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.DirichletCorr">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">DirichletCorr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">temp</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-06</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#DirichletCorr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.DirichletCorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a correlation matrix by sampling p eigenvalues
from a dirichlet distribution whose <cite>p</cite> parameters are i.i.d.
uniform [<cite>tol</cite>, <cite>temp</cite>] and generating a random covariance matrix
with those eigenvalues.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.ErdosRenyi">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">ErdosRenyi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">300</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">lower</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">upper</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#ErdosRenyi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.ErdosRenyi" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly samples bernoulli flags as well as values
for partial correlations to generate sparse square
matrices. Follows <a class="reference external" href="https://arxiv.org/pdf/1908.11611.pdf">https://arxiv.org/pdf/1908.11611.pdf</a>.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.FactorModel">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">FactorModel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">rank</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#FactorModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.FactorModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates random correlation matrix from a factor model 
with dimension <cite>p</cite> and rank <cite>rank</cite>.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.NestedAR1">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">NestedAR1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">a</span><span class="o">=</span><span class="default_value">7</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">num_nests</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">nest_size</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#NestedAR1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.NestedAR1" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates correlation matrix for AR(1) Gaussian process
with hierarchical correlation structure.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.PartialCorr">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">PartialCorr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">300</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">0.3</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#PartialCorr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.PartialCorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a correlation matrix of dimension <cite>p</cite> with partial correlation <cite>rho</cite>.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.UniformDot">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">UniformDot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#UniformDot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.UniformDot" title="Permalink to this definition">¶</a></dt>
<dd><p>Let U be a random <cite>d</cite> x <cite>p</cite> matrix with i.i.d. uniform
entries. Then Sigma = <a href="#id3"><span class="problematic" id="id4">``</span></a>cov2corr``(U^T U)</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.Wishart">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">Wishart</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#Wishart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.Wishart" title="Permalink to this definition">¶</a></dt>
<dd><p>Let W be a random <cite>d</cite> x <cite>p</cite> matrix with i.i.d. Gaussian
entries. Then Sigma = <a href="#id5"><span class="problematic" id="id6">``</span></a>cov2corr``(W^T W).</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.block_equi_graph">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">block_equi_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">3000</span></em>, <em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">block_size</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">sparsity</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">gamma</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">coeff_size</span><span class="o">=</span><span class="default_value">3.5</span></em>, <em class="sig-param"><span class="n">coeff_dist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sign_prob</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">iid_signs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">corr_signals</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#block_equi_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.block_equi_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples data according to a block-equicorrelated Gaussian design,
where <code class="docutils literal notranslate"><span class="pre">rho</span></code> is the within-block correlation and <code class="docutils literal notranslate"><span class="pre">gamma</span> <span class="pre">*</span> <span class="pre">rho</span></code>
is the between-block correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of data points</p>
</dd>
<dt><strong>p</strong><span class="classifier">int</span></dt><dd><p>The dimensionality of the data</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">int</span></dt><dd><p>The size of blocks. Defaults to 5.</p>
</dd>
<dt><strong>sparsity</strong><span class="classifier">float</span></dt><dd><p>The proportion of groups which are null. Defaults to 0.1</p>
</dd>
<dt><strong>rho</strong><span class="classifier">float</span></dt><dd><p>The within-group correlation</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>The between-group correlation is <code class="docutils literal notranslate"><span class="pre">gamma</span> <span class="pre">*</span> <span class="pre">rho</span></code></p>
</dd>
<dt><strong>beta</strong><span class="classifier">np.ndarray</span></dt><dd><p>If supplied, the <code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped set of coefficients. Else,
will be generated by calling 
<code class="docutils literal notranslate"><span class="pre">knockpy.dgp.sample_sparse_coefficients.</span></code></p>
</dd>
<dt><strong>mu</strong><span class="classifier">np.ndarray</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">p</span></code>-dimensional mean of the covariates. Defaults to 0.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Args passed to <code class="docutils literal notranslate"><span class="pre">knockpy.dgp.sample_response</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This defaults to the same data-generating process as
Dai and Barber 2016 (see <a class="reference external" href="https://arxiv.org/abs/1602.03589">https://arxiv.org/abs/1602.03589</a>).</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.construct_gibbs_grid">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">construct_gibbs_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">temp</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#construct_gibbs_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.construct_gibbs_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates gridlike <code class="docutils literal notranslate"><span class="pre">gibbs_graph</span></code> parameter for <code class="docutils literal notranslate"><span class="pre">sample_gibbs</span></code>.
See <code class="docutils literal notranslate"><span class="pre">sample_gibbs</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.coords2num">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">coords2num</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">w</span></em>, <em class="sig-param"><span class="n">gridwidth</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#coords2num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.coords2num" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes coordinates of variable in a Gibbs grid, returns position</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.cov2blocks">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">cov2blocks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-05</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#cov2blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.cov2blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes a PREORDERED block-diagonal matrix V into its blocks.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.create_correlation_tree">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">create_correlation_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">corr_matrix</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'average'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#create_correlation_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.create_correlation_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates hierarchical clustering (correlation tree)
from a correlation matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>corr_matrix</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped correlation matrix</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>the method of hierarchical clustering:
‘single’, ‘average’, ‘fro’, or ‘complete’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>link</strong><span class="classifier">np.ndarray</span></dt><dd><p>The <cite>link</cite> of the correlation tree, as in scipy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.create_sparse_coefficients">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">create_sparse_coefficients</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">sparsity</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">coeff_size</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">coeff_dist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sign_prob</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">iid_signs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">corr_signals</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#create_sparse_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.create_sparse_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a set of sparse coefficients for single index or sparse additive models.
p : int</p>
<blockquote>
<div><p>Dimensionality of coefficients</p>
</div></blockquote>
<dl class="simple">
<dt>sparsity<span class="classifier">float</span></dt><dd><p>Proportion of non-null coefficients. Generates <code class="docutils literal notranslate"><span class="pre">np.floor(p*sparsity)</span></code> non-nulls.</p>
</dd>
<dt>coeff_size: float</dt><dd><p>Size of non-zero coefficients</p>
</dd>
<dt>groups<span class="classifier">np.ndarray</span></dt><dd><p>A p-length array of integers from 1 to num_groups such that
<code class="docutils literal notranslate"><span class="pre">groups[j]</span> <span class="pre">==</span> <span class="pre">i</span></code> indicates that variable <cite>j</cite> is a member of group <cite>i</cite>.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>. Else, floor(sparsity * num_groups) groups will be 
chosen to be non-null, where all elements of each group are non-null.</p>
</dd>
<dt>sign_prob<span class="classifier">float</span></dt><dd><p>The probability that each nonzero coefficient will be positive.</p>
</dd>
<dt>iid_signs<span class="classifier">bool</span></dt><dd><p>If True, the signs of the coeffs are assigned independently.
Else, exactly sign_prob*sparsity*p coefficients will be positive.</p>
</dd>
<dt>coeff_dist<span class="classifier">str</span></dt><dd><p>Specifies the distribution of nonzero coefficients. Three options:
- <code class="docutils literal notranslate"><span class="pre">None</span></code>: all coefficients have absolute value coeff_size.
- <code class="docutils literal notranslate"><span class="pre">normal</span></code>: all nonzero coefficients are drawn from Normal(coeff_size, 1). 
- <code class="docutils literal notranslate"><span class="pre">uniform</span></code>: nonzero coeffs are drawn from Unif(coeff_size/2, coeff_size).</p>
</dd>
<dt>corr_signals<span class="classifier">bool</span></dt><dd><p>If true, all of the nonzero coefficients will lie in a consecutive block.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>beta</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped array of sparse coefficients</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.graph2cliques">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">graph2cliques</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Q</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#graph2cliques"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.graph2cliques" title="Permalink to this definition">¶</a></dt>
<dd><p>Turns graph Q of connections into binary cliques for Gibbs grid</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.num2coords">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">num2coords</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">gridwidth</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#num2coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.num2coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordinates of variable i in a Gibbs grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Position of variable in ordering</p>
</dd>
<dt><strong>gridwidth</strong><span class="classifier">int</span></dt><dd><p>Width of the grid</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>length_coord, width_coord (coordinates)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.sample_ar1t">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">sample_ar1t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rhos</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">df_t</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#sample_ar1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.sample_ar1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples t-distributed variables according to a Markov chain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rhos</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p-1,</span> <span class="pre">)</span></code>-length array of correlations between consecutive
variables.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of data points to sample</p>
</dd>
<dt><strong>df_t</strong><span class="classifier">float</span></dt><dd><p>The degrees of freedom of the t variables</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.sample_block_tmvn">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">sample_block_tmvn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">blocks</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">df_t</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#sample_block_tmvn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.sample_block_tmvn" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples a blocks of multivariate-t distributed variables
according to a list of covariance matrices called <code class="docutils literal notranslate"><span class="pre">blocks</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocks</strong><span class="classifier">list</span></dt><dd><p>A list of square, symmetric numpy arrays. These are
the covariance matrices for each block of variables.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of data points to sample</p>
</dd>
<dt><strong>df_t</strong><span class="classifier">float</span></dt><dd><p>The degrees of freedom of the t-distribution</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The variables are scaled such that the marginal variance
of each variable equals a diagonal element in one of the blocks.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.sample_gibbs">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">sample_gibbs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">gibbs_graph</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">temp</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">15</span></em>, <em class="sig-param"><span class="n">K</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">max_val</span><span class="o">=</span><span class="default_value">2.5</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#sample_gibbs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.sample_gibbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples from a discrete Gibbs measure using a gibbs sampler.</p>
<p>The joint likelihood for the <cite>p</cite>-dimensional data X1 through Xp
is the product of all terms of the following form:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">`np.exp(-1*gibbs_graph[i,j]*np.abs(Xi</span> <span class="pre">-</span> <span class="pre">Xj))`</span></code></p>
</div></blockquote>
<p>where <cite>gibbs_graph</cite> is assumed to be symmetric (and is usually
sparse). Each feature takes values on an evenly spaced grid from
<code class="docutils literal notranslate"><span class="pre">-1*max_val</span></code> to <code class="docutils literal notranslate"><span class="pre">max_val</span></code> with <code class="docutils literal notranslate"><span class="pre">K</span></code> values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>How many data points to sample</p>
</dd>
<dt><strong>p</strong><span class="classifier">int</span></dt><dd><p>Dimensionality of the data</p>
</dd>
<dt><strong>gibbs_graph</strong><span class="classifier">np.ndarray</span></dt><dd><p>A symmetric <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped array. See likelihood equation.
By default, this is corresponds to an undirected graphical
model with a square grid (like an Ising model) with nonzero
entries set to 1 or -1 with equal probability.</p>
</dd>
<dt><strong>temp</strong><span class="classifier">float</span></dt><dd><p>Governs the strength of interactions between features—see 
the likelihood equation.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int</span></dt><dd><p>Number of iterations in the Gibbs sampler; defaults to 15.</p>
</dd>
<dt><strong>K</strong><span class="classifier">int</span></dt><dd><p>Number of discrete values each sampled feature can take.</p>
</dd>
<dt><strong>max_val</strong><span class="classifier">float</span></dt><dd><p>The maximum absolute value each feature can take.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped array of data</p>
</dd>
<dt><strong>gibbs_graph</strong><span class="classifier">np.ndarray</span></dt><dd><p>The generated <cite>gibbs_graph</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.dgp.sample_response">
<code class="sig-prename descclassname">knockpy.dgp.</code><code class="sig-name descname">sample_response</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">cond_mean</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">y_dist</span><span class="o">=</span><span class="default_value">'gaussian'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/dgp.html#sample_response"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.dgp.sample_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a design matrix X and coefficients beta, samples a response y.</p>
<dl>
<dt>X<span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt>beta<span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">)</span></code>-shaped coefficient vector</p>
</dd>
<dt>cond_mean<span class="classifier">str</span></dt><dd><p>How to calculate the conditional mean of y given X, denoted mu(X). 
Six options:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>“linear” denotes <code class="docutils literal notranslate"><span class="pre">np.dot(X,</span> <span class="pre">beta)</span></code></p></li>
<li><p>“cubic” denotes <code class="docutils literal notranslate"><span class="pre">np.dot(X**3,</span> <span class="pre">beta)</span> <span class="pre">-</span> <span class="pre">np.dot(X,</span> <span class="pre">beta)</span></code></p></li>
</ol>
<p>3. “trunclinear” <code class="docutils literal notranslate"><span class="pre">((X</span> <span class="pre">*</span> <span class="pre">beta</span> <span class="pre">&gt;=</span> <span class="pre">1).sum(axis</span> <span class="pre">=</span> <span class="pre">1))</span></code>
Stands for truncated linear.
4. “pairint”: pairs up non-null coefficients according to the
order of beta, multiplies them and their beta values, then
sums. “pairint” stands for pairwise-interactions.
5. “cos”: <code class="docutils literal notranslate"><span class="pre">mu(X)</span> <span class="pre">=</span> <span class="pre">sign(beta)</span> <span class="pre">*</span> <span class="pre">(beta</span> <span class="pre">!=</span> <span class="pre">0)</span> <span class="pre">*</span> <span class="pre">np.cos(X)</span></code>
6. “quadratic”: <code class="docutils literal notranslate"><span class="pre">mu(X)</span> <span class="pre">=</span> <span class="pre">np.dot(np.power(X,</span> <span class="pre">2),</span> <span class="pre">beta)</span></code></p>
</div></blockquote>
</dd>
<dt>y_dist<span class="classifier">str</span></dt><dd><p>If “gaussian”, y is the conditional mean plus gaussian noise.
If “binomial”, Pr(y=1) = softmax(cond_mean).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,)</span></code>-shaped response vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-knockpy.utilities">
<span id="utility-functions"></span><h2>Utility functions<a class="headerlink" href="#module-knockpy.utilities" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="knockpy.utilities.apply_pool">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">apply_pool</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">constant_inputs</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">num_processes</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#apply_pool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.apply_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawns num_processes processes to apply func to many different arguments.
This wraps the multiprocessing.pool object plus the functools partial function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>An arbitrary function</p>
</dd>
<dt><strong>constant_inputs</strong><span class="classifier">dictionary</span></dt><dd><p>A dictionary of arguments to func which do not change in each
of the processes spawned, defaults to {}.</p>
</dd>
<dt><strong>num_processes</strong><span class="classifier">int</span></dt><dd><p>The maximum number of processes spawned, defaults to 1.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Each key should correspond to an argument to func and should
map to a list of different arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>outputs</strong><span class="classifier">list</span></dt><dd><p>List of outputs for each input, in the order of the inputs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.blockdiag_to_blocks">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">blockdiag_to_blocks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">groups</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#blockdiag_to_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.blockdiag_to_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a square array <cite>M</cite>, returns a list of diagonal blocks of <cite>M</cite> as specified by <cite>groups</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocks</strong><span class="classifier">list</span></dt><dd><p>A list of square np.ndarrays. blocks[i] corresponds to group identified
by the ith smallest unique value of <code class="docutils literal notranslate"><span class="pre">groups</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.calc_group_sizes">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">calc_group_sizes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#calc_group_sizes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.calc_group_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of groups, finds the sizes of the groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>groups</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">)</span></code>-shaped array which takes m integer values from
1 to m. If <code class="docutils literal notranslate"><span class="pre">groups[i]</span> <span class="pre">==</span> <span class="pre">j</span></code>, this indicates that coordinate
<code class="docutils literal notranslate"><span class="pre">i</span></code> belongs to group <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
</dd>
<dt><strong>:param groups: p-length array of integers between 1 and m,</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sizes</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">)</span></code>-length array of group sizes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.chol2inv">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">chol2inv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#chol2inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.chol2inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses cholesky decomp to get inverse of matrix</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.cov2corr">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">cov2corr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#cov2corr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.cov2corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales a p x p cov. matrix M to be a correlation matrix</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.estimate_covariance">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">estimate_covariance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">shrinkage</span><span class="o">=</span><span class="default_value">'ledoitwolf'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#estimate_covariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.estimate_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates covariance matrix of X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code>-shaped design matrix</p>
</dd>
<dt><strong>shrinkage</strong><span class="classifier">str</span></dt><dd><p>The type of shrinkage to apply during estimation. One of
“ledoitwolf”, “graphicallasso”, or None (no shrinkage).</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>If shrinkage is None but the minimum eigenvalue of the MLE
is below tol, apply LedoitWolf shrinkage anyway.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>kwargs to pass to the shrinkage estimator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped estimated covariance matrix of X</p>
</dd>
<dt><strong>invSigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped estimated precision matrix of X</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.estimate_factor">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">estimate_factor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">num_factors</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">num_iter</span><span class="o">=</span><span class="default_value">10</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#estimate_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.estimate_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximates <code class="docutils literal notranslate"><span class="pre">Sigma</span> <span class="pre">=</span> <span class="pre">np.diag(D)</span> <span class="pre">+</span> <span class="pre">np.dot(U,</span> <span class="pre">U.T)</span></code>.
See <a class="reference external" href="https://arxiv.org/pdf/2006.08790.pdf">https://arxiv.org/pdf/2006.08790.pdf</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Sigma</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">p)</span></code>-shaped covariance matrix of X</p>
</dd>
<dt><strong>num_factors</strong><span class="classifier">int</span></dt><dd><p>Dimensionality of <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>D</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,)</span></code>-shaped array of diagonal elements.</p>
</dd>
<dt><strong>U</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">num_factors)</span></code>-shaped array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>TODO: allow X as an input when Sigma does not
fit in memory.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.fetch_group_nonnulls">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">fetch_group_nonnulls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">non_nulls</span></em>, <em class="sig-param"><span class="n">groups</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#fetch_group_nonnulls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.fetch_group_nonnulls" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines feature-level null hypotheses into group-level hypothesis.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.permute_matrix_by_groups">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">permute_matrix_by_groups</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#permute_matrix_by_groups"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.permute_matrix_by_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Create indices which permute a (covariance) matrix according to a list of groups.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.preprocess_groups">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">preprocess_groups</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">groups</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#preprocess_groups"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.preprocess_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the m unique elements of a 1D “groups” array to the integers from 1 to m.</p>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.random_permutation_inds">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">random_permutation_inds</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#random_permutation_inds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.random_permutation_inds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indexes which will randomly permute/unpermute a numpy
array of length <cite>length</cite>. Also returns indices which will
undo this permutation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inds</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(length,)</span></code>-shaped ndarray corresponding to a random permutation
from 0 to <cite>length</cite>-1.</p>
</dd>
<dt><strong>rev_inds</strong><span class="classifier">np.ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">(length,)</span></code>-shaped ndarray such that for any <code class="docutils literal notranslate"><span class="pre">(length,)</span></code>-shaped 
array called <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">x[inds][rev_inds]</span></code> equals <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.scale_until_PSD">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">scale_until_PSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Sigma</span></em>, <em class="sig-param"><span class="n">S</span></em>, <em class="sig-param"><span class="n">tol</span></em>, <em class="sig-param"><span class="n">num_iter</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#scale_until_PSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.scale_until_PSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a binary search to find the largest <code class="docutils literal notranslate"><span class="pre">gamma</span></code> such that the minimum
eigenvalue of <code class="docutils literal notranslate"><span class="pre">2*Sigma</span> <span class="pre">-</span> <span class="pre">gamma*S</span></code> is at least <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gamma * S</strong><span class="classifier">np.ndarray</span></dt><dd><p>See description.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>See description</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="knockpy.utilities.shift_until_PSD">
<code class="sig-prename descclassname">knockpy.utilities.</code><code class="sig-name descname">shift_until_PSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">M</span></em>, <em class="sig-param"><span class="n">tol</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/knockpy/utilities.html#shift_until_PSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#knockpy.utilities.shift_until_PSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the identity until a p x p matrix M has eigenvalues of at least tol</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="usage.html" class="btn btn-neutral float-left" title="Tutorials" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Asher Spector

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: v1.0.4
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="../v1.0.3/apiref.html">v1.0.3</a></dd>
      <dd><a href="apiref.html">v1.0.4</a></dd>
    </dl>
  </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>